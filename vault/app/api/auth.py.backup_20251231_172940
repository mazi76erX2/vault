from __future__ import annotations

from typing import Optional

from app.database import supabase
from app.services.auth_service import (CurrentUser, _extract_bearer_token,
                                      get_current_user)
from fastapi import APIRouter, HTTPException, Request, status
from pydantic import BaseModel, EmailStr

router = APIRouter(prefix="/api/v1/auth", tags=["auth"])


class LoginRequest(BaseModel):
    email: EmailStr
    password: str


class UserOut(BaseModel):
    id: str
    email: Optional[str] = None


class LoginResponse(BaseModel):
    user: UserOut
    token: str
    refreshToken: Optional[str] = None


class RefreshTokenRequest(BaseModel):
    refreshToken: str


class RefreshTokenResponse(BaseModel):
    user: UserOut
    token: str
    refreshToken: Optional[str] = None


@router.post("/login", response_model=LoginResponse)
async def login(req: LoginRequest):
    if supabase is None:
        raise HTTPException(
            status_code=status.HTTP500_INTERNAL_SERVER_ERROR,
            detail="Supabase client not configured (set SUPABASE_URL and SUPABASE_KEY)",
        )

    try:
        auth_resp = supabase.auth.sign_in_with_password(
            {"email": str(req.email), "password": req.password}
        )
        if not auth_resp or not auth_resp.user or not auth_resp.session:
            raise HTTPException(
                status_code=status.HTTP401_UNAUTHORIZED, detail="Invalid credentials"
            )

        return LoginResponse(
            user=UserOut(id=auth_resp.user.id, email=auth_resp.user.email),
            token=auth_resp.session.access_token,
            refreshToken=auth_resp.session.refresh_token,
        )
    except HTTPException:
        raise
    except Exception as e:
        msg = str(e)
        if "SSL" in msg or "connect" in msg.lower():
            msg = "Failed to connect to authentication service. Please try again."
        raise HTTPException(
            status_code=status.HTTP500_INTERNAL_SERVER_ERROR, detail=msg
        ) from e


@router.post("/refresh", response_model=RefreshTokenResponse)
async def refresh(req: RefreshTokenRequest):
    if supabase is None:
        raise HTTPException(
            status_code=status.HTTP500_INTERNAL_SERVER_ERROR,
            detail="Supabase client not configured (set SUPABASE_URL and SUPABASE_KEY)",
        )

    try:
        refresh_resp = supabase.auth.refresh_session(req.refreshToken)
        if not refresh_resp or not refresh_resp.user or not refresh_resp.session:
            raise HTTPException(
                status_code=status.HTTP401_UNAUTHORIZED, detail="Invalid refresh token"
            )

        return RefreshTokenResponse(
            user=UserOut(id=refresh_resp.user.id, email=refresh_resp.user.email),
            token=refresh_resp.session.access_token,
            refreshToken=refresh_resp.session.refresh_token,
        )
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP401_UNAUTHORIZED,
            detail=f"Could not refresh token: {e}",
        ) from e


@router.post("/logout")
async def logout(request: Request):
    if supabase is None:
        return {"status": "ok"}

    token = _extract_bearer_token(request)
    try:
        supabase.auth.sign_out(jwt=token)
    except Exception:
        pass
    return {"status": "ok"}


@router.get("/me", response_model=UserOut)
async def me(request: Request):
    user: CurrentUser = get_current_user(request)
    return UserOut(id=user.user_id, email=user.email)
