# app/api/collector.py
from __future__ import annotations

import logging
import os
import shutil
from datetime import datetime
from pathlib import Path
from typing import Any, Dict, List, Optional

from app.database import supabase
from app.dto.collector import (CollectorSummaryContinueRequest,
                               CollectorSummaryContinueResponse,
                               CollectorSummaryUpdateSummaryRequest,
                               ProfileUpdateRequest, StartChatRequest)
from app.middleware.auth import verifytoken
from app.services.collector_llm import (generate_follow_up_question,
                                        generate_initial_questions,
                                        generate_summary, generate_tags,
                                        generate_topic_from_question)
from app.services.file_extract import extract_text
from fastapi import APIRouter, Depends, File, HTTPException, UploadFile, status
from gotrue import UserResponse

router = APIRouter(prefix="/api/v1/collector", tags=["collector"])
logger = logging.getLogger(__name__)

UPLOADDIR = ".uploads"
os.makedirs(UPLOADDIR, exist_ok=True)


def _must_userid(user: UserResponse) -> str:
    uid = getattr(getattr(user, "user", None), "id", None)
    if not uid:
        raise HTTPException(status_code=400, detail="Missing user id")
    return str(uid)


@router.post("/updatecvtext")
def updatecvtext(
    file: UploadFile = File(...), user: UserResponse = Depends(verifytoken)
) -> Dict[str, Any]:
    userid = _must_userid(user)

    filepath = os.path.join(UPLOADDIR, file.filename)
    try:
        with open(filepath, "wb") as buffer:
            shutil.copyfileobj(file.file, buffer)

        cvtext = extract_text(Path(filepath)).strip()
        if not cvtext:
            raise HTTPException(
                status_code=400, detail="Could not extract CV text from file"
            )

        resp = (
            supabase.table("profiles")
            .update({"CVtext": cvtext})
            .eq("id", userid)
            .execute()
        )
        if not resp.data:
            raise HTTPException(
                status_code=404, detail="User profile not found or no changes made"
            )

        return {"cvtext": cvtext}
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))
    finally:
        try:
            os.remove(filepath)
        except Exception:
            pass


@router.post("/fetchresumesessions")
def fetchresumesessions(user: UserResponse = Depends(verifytoken)) -> Dict[str, Any]:
    userid = _must_userid(user)
    try:
        resp = (
            supabase.table("sessions")
            .select("*")
            .eq("userid", userid)
            .eq("status", "Started")
            .execute()
        )
        return {"sessions": resp.data or []}
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))


@router.post("/fetchuserprofile")
async def fetchuserprofile(user: UserResponse = Depends(verifytoken)) -> Dict[str, Any]:
    userid = _must_userid(user)
    try:
        resp = (
            supabase.table("profiles")
            .select("fullname, yearsofexperience, fieldofexpertise, department, CVtext")
            .eq("id", userid)
            .execute()
        )
        if not resp.data:
            raise HTTPException(status_code=404, detail="No profile found")
        data = resp.data[0]
        return {
            "fullname": data.get("fullname", ""),
            "yearsofexperience": data.get("yearsofexperience", None),
            "fieldofexpertise": data.get("fieldofexpertise", ""),
            "department": data.get("department", ""),
            "CVtext": data.get("CVtext", None),
        }
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))


@router.post("/updateprofile")
def updateprofile(
    request: ProfileUpdateRequest, user: UserResponse = Depends(verifytoken)
) -> Dict[str, Any]:
    _ = _must_userid(user)
    try:
        resp = (
            supabase.table("profiles")
            .upsert(
                {
                    "id": request.userid,
                    "fullname": request.fullname,
                    "yearsofexperience": request.yearsofexperience,
                    "fieldofexpertise": request.fieldofexpertise,
                    "department": request.department,
                },
                on_conflict="id",
            )
            .execute()
        )
        return {"message": "Profile updated successfully", "data": resp.data}
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))


@router.post("/fetchchatconversation")
def fetchchatconversation(
    data: Dict[str, Any], user: UserResponse = Depends(verifytoken)
) -> Dict[str, Any]:
    _ = _must_userid(user)
    sessionid = data.get("sessionid")
    chatmessagesid = data.get("chatmessagesid")

    if not sessionid:
        raise HTTPException(status_code=400, detail="Missing sessionid")

    try:
        if not chatmessagesid:
            sresp = (
                supabase.table("sessions")
                .select("chatmessagesid")
                .eq("id", sessionid)
                .maybe_single()
                .execute()
            )
            sdata = sresp.data or {}
            chatmessagesid = sdata.get("chatmessagesid")
            if not chatmessagesid:
                return {"chatmessagesid": None, "messages": None}

        cresp = (
            supabase.table("chatmessagescollector")
            .select("messages")
            .eq("id", chatmessagesid)
            .maybe_single()
            .execute()
        )
        cdata = cresp.data or {}
        return {"chatmessagesid": chatmessagesid, "messages": cdata.get("messages")}
    except Exception as e:
        raise HTTPException(
            status_code=500, detail=f"Failed to fetch chat conversation: {str(e)}"
        )


@router.get("/fetchdocumentsstatus")
def fetchdocumentsstatus(user: UserResponse = Depends(verifytoken)) -> Dict[str, Any]:
    userid = _must_userid(user)
    try:
        profileresp = supabase.table("profiles").select("id, fullname").execute()
        profiles = profileresp.data or []
        usermap = {p["id"]: p.get("fullname", "NA") for p in profiles if p.get("id")}

        docresp = (
            supabase.table("documents")
            .select("docid, title, responsible, status")
            .neq("status", "Draft")
            .eq("authorid", userid)
            .execute()
        )
        documents = docresp.data or []
        if not documents:
            raise HTTPException(status_code=404, detail="No completed documents found")

        rows = []
        for d in documents:
            rows.append(
                {
                    "id": d.get("docid"),
                    "title": d.get("title", "Untitled"),
                    "responsible": usermap.get(d.get("responsible"), "NA"),
                    "status": d.get("status", "Pending"),
                }
            )
        return {"documents": rows}
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))


@router.get("/getvalidators")
def getvalidators(user: UserResponse = Depends(verifytoken)) -> Dict[str, Any]:
    _ = _must_userid(user)
    try:
        profileresp = supabase.table("profiles").select("id, fullname").execute()
        profiles = profileresp.data or []
        validators = [
            {"id": p.get("id"), "fullname": p.get("fullname", "NA")}
            for p in profiles
            if p.get("id")
        ]
        return {"validators": validators}
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))


@router.post("/get-questions")
async def getquestions(
    request: Dict[str, Any], user: UserResponse = Depends(verifytoken)
) -> Dict[str, Any]:
    _ = _must_userid(user)
    userid = request.get("userid")
    if not userid:
        raise HTTPException(status_code=400, detail="Missing userid")

    try:
        topics_available = True
        try:
            resp = (
                supabase.table("questions")
                .select("questions, status, topics")
                .eq("userid", userid)
                .execute()
            )
        except Exception as e:
            if "column" in str(e).lower() and "topics" in str(e).lower():
                topics_available = False
                resp = (
                    supabase.table("questions")
                    .select("questions, status")
                    .eq("userid", userid)
                    .execute()
                )
            else:
                raise

        if resp.data is None:
            raise HTTPException(
                status_code=500, detail="Failed to retrieve questions from database"
            )
        if not resp.data:
            raise HTTPException(
                status_code=404,
                detail="No questions found. Click Generate to create new questions or Upload Questions to import from a file.",
            )

        row = resp.data[0]
        return {
            "questions": row.get("questions", []),
            "status": row.get("status", []),
            "topics": row.get("topics", []) if topics_available else [],
        }
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(
            status_code=500, detail=f"Error fetching questions: {str(e)}"
        )


@router.post("/generatequestions")
def generatequestions(
    data: Dict[str, Any], user: UserResponse = Depends(verifytoken)
) -> Dict[str, Any]:
    _ = _must_userid(user)
    userid = data.get("userid")
    if not userid:
        raise HTTPException(status_code=400, detail="Missing userid")

    try:
        prof = (
            supabase.table("profiles")
            .select("fullname, yearsofexperience, fieldofexpertise, department, CVtext")
            .eq("id", userid)
            .maybe_single()
            .execute()
        ).data or {}

        questions, _seed = generate_initial_questions(prof, n=8)
        topics: List[str] = [generate_topic_from_question(q) for q in questions]
        status_list = ["Not Started" for _ in questions]

        upsertdata = {
            "userid": userid,
            "questions": questions,
            "createdat": datetime.now().isoformat(),
            "status": status_list,
        }
        # topics column may not exist; only return topics to frontend
        supabase.table("questions").upsert(upsertdata, on_conflict="userid").execute()

        return {"questions": questions, "status": status_list, "topics": topics}
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))


@router.post("/initquestions")
def initquestionsfromupload(
    data: Dict[str, Any], user: UserResponse = Depends(verifytoken)
) -> Dict[str, Any]:
    _ = _must_userid(user)
    userid = data.get("userid")
    questionslist = data.get("questions")
    if not userid or not questionslist:
        raise HTTPException(status_code=400, detail="Missing userid or questions list")

    try:
        topics: List[str] = [generate_topic_from_question(q) for q in questionslist]
        status_list = ["Not Started" for _ in questionslist]

        upsertdata = {
            "userid": userid,
            "questions": questionslist,
            "createdat": datetime.now().isoformat(),
            "status": status_list,
        }
        supabase.table("questions").upsert(upsertdata, on_conflict="userid").execute()

        return {
            "message": "Questions initialized successfully",
            "questions": questionslist,
            "status": status_list,
            "topics": topics,
        }
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))


@router.post("/start-chat")
async def start_chat(
    request: StartChatRequest, user: UserResponse = Depends(verifytoken)
) -> Dict[str, Any]:
    userid = _must_userid(user)

    try:
        # 0) companyid
        prof = (
            supabase.table("profiles")
            .select("companyid")
            .eq("id", userid)
            .maybe_single()
            .execute()
            .data
            or {}
        )
        companyid = prof.get("companyid")
        if not companyid:
            raise HTTPException(
                status_code=400,
                detail="User does not have a company associated with their profile",
            )

        # 1) create Draft document
        docins = (
            supabase.table("documents")
            .insert(
                {
                    "authorid": userid,
                    "title": f"Draft Document - {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}",
                    "severitylevels": "Low",
                    "status": "Draft",
                    "companyid": companyid,
                }
            )
            .execute()
        )
        if not docins.data or not docins.data[0].get("docid"):
            raise HTTPException(
                status_code=500, detail="Failed to create initial document record"
            )
        docid = docins.data[0]["docid"]

        # 2) create session
        topic = generate_topic_from_question(request.question)
        sins = (
            supabase.table("sessions")
            .insert(
                {
                    "userid": userid,
                    "docid": docid,
                    "createdat": datetime.now().isoformat(),
                    "topic": topic,
                    "status": "Started",
                }
            )
            .execute()
        )
        if not sins.data or not sins.data[0].get("id"):
            raise HTTPException(
                status_code=500, detail="Failed to create session record"
            )
        sessionid = sins.data[0]["id"]

        # 3) create chatmessagescollector with system+initial assistant message
        systemmessage = {
            "role": "system",
            "content": (
                "You are a dynamic and engaging chatbot designed to ask open-ended questions to collect knowledge "
                "and experiences from employees. Only ask follow-up questions. Do not summarize or answer."
            ),
        }
        initialquestion = {"role": "assistant", "content": request.question}
        messages = [systemmessage, initialquestion]

        cins = (
            supabase.table("chatmessagescollector")
            .insert(
                {
                    "sessionid": sessionid,
                    "messages": messages,
                    "createdat": datetime.now().isoformat(),
                }
            )
            .execute()
        )
        if not cins.data or not cins.data[0].get("id"):
            raise HTTPException(
                status_code=500, detail="Failed to insert chatmessagecollector"
            )
        chatmsgid = cins.data[0]["id"]

        # 4) update session with chatmessagesid
        supabase.table("sessions").update({"chatmessagesid": chatmsgid}).eq(
            "id", sessionid
        ).execute()

        # 5) update question status (best-effort)
        try:
            qrow = (
                supabase.table("questions")
                .select("status")
                .eq("userid", userid)
                .maybe_single()
                .execute()
                .data
                or {}
            )
            status_list = qrow.get("status") or []
            idx = int(request.id) - 1
            if 0 <= idx < len(status_list):
                status_list[idx] = "Started"
                supabase.table("questions").update({"status": status_list}).eq(
                    "userid", userid
                ).execute()
        except Exception:
            logger.exception("Question status update failed (non-fatal)")

        return {
            "message": "Session created successfully",
            "sessionId": sessionid,
            "chatMessageId": chatmsgid,
            "resume": False,
        }
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))


@router.post("/generatequestionresponse")
def generatequestionresponse(
    data: Dict[str, Any], user: UserResponse = Depends(verifytoken)
) -> Dict[str, Any]:
    _ = _must_userid(user)
    chatpromptid = data.get("chatpromptid")
    usertext = data.get("usertext")
    if not chatpromptid:
        raise HTTPException(status_code=400, detail="Missing chatpromptid")
    if not usertext:
        raise HTTPException(status_code=400, detail="Missing usertext")

    try:
        chatrow = (
            supabase.table("chatmessagescollector")
            .select("messages")
            .eq("id", chatpromptid)
            .maybe_single()
            .execute()
        ).data
        if not chatrow:
            raise HTTPException(status_code=404, detail="Chat session not found")

        messages = chatrow.get("messages") or []
        followup, updated_messages = generate_follow_up_question(messages, usertext)

        supabase.table("chatmessagescollector").update(
            {"messages": updated_messages}
        ).eq("id", chatpromptid).execute()
        return {"followupquestion": followup}
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))


@router.post("/generatesummary")
def generatesummary(
    data: Dict[str, Any], user: UserResponse = Depends(verifytoken)
) -> Dict[str, Any]:
    _ = _must_userid(user)
    chatpromptid = data.get("chatpromptid")
    if not chatpromptid:
        raise HTTPException(status_code=400, detail="Missing chatpromptid")

    try:
        chatrow = (
            supabase.table("chatmessagescollector")
            .select("messages")
            .eq("id", chatpromptid)
            .maybe_single()
            .execute()
        ).data or {}

        messages = chatrow.get("messages") or []
        summ = generate_summary(messages)
        return {"chatsummary": summ}
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))


@router.post("/generatetags")
def generatetags_endpoint(
    data: Dict[str, Any], user: UserResponse = Depends(verifytoken)
) -> Dict[str, Any]:
    _ = _must_userid(user)
    text = data.get("text") or ""
    if not text.strip():
        raise HTTPException(status_code=400, detail="Missing text")
    try:
        tags = generate_tags(text)
        return {"tags": tags}
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))


@router.post("/updatesummary")
def updatesummary(
    request: CollectorSummaryUpdateSummaryRequest,
    user: UserResponse = Depends(verifytoken),
) -> Dict[str, Any]:
    _ = _must_userid(user)

    try:
        srow = (
            supabase.table("sessions")
            .select("docid")
            .eq("id", request.sessionid)
            .maybe_single()
            .execute()
        ).data or {}
        docid = srow.get("docid")
        if not docid:
            raise HTTPException(
                status_code=404, detail="Session not found or missing docid"
            )

        # Persist summary on document
        supabase.table("documents").update({"summary": request.summarytext}).eq(
            "docid", docid
        ).execute()
        return {"message": "Summary updated successfully"}
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))


@router.post("/continuesession", response_model=CollectorSummaryContinueResponse)
def continuesession(
    request: CollectorSummaryContinueRequest, user: UserResponse = Depends(verifytoken)
) -> CollectorSummaryContinueResponse:
    _ = _must_userid(user)
    # UI uses this only for navigation state
    return CollectorSummaryContinueResponse(
        message="Summary updated successfully",
        nextpage="/applications/collector/CollectorMetaDataPage",
        state={
            "summarytext": request.summarytext,
            "sessionid": request.sessionid,
            "isresume": request.isresume,
        },
    )


@router.post("/fetchexistingdoc")
def fetchexistingdoc(
    data: Dict[str, Any], user: UserResponse = Depends(verifytoken)
) -> Dict[str, Any]:
    _ = _must_userid(user)
    sessionid = data.get("sessionid")
    if not sessionid:
        raise HTTPException(status_code=400, detail="Missing sessionId")

    try:
        srow = (
            supabase.table("sessions")
            .select("docid")
            .eq("id", sessionid)
            .maybe_single()
            .execute()
            .data
            or {}
        )
        docid = srow.get("docid")
        if not docid:
            raise HTTPException(
                status_code=404, detail="Session not found or missing docid"
            )

        doc = (
            supabase.table("documents")
            .select("*")
            .eq("docid", docid)
            .maybe_single()
            .execute()
            .data
        )
        return {"document": doc}
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))


@router.post("/updatesessionanddocument")
def updatesessionanddocument(
    data: Dict[str, Any], user: UserResponse = Depends(verifytoken)
) -> Dict[str, Any]:
    _ = _must_userid(user)

    sessionid = data.get("sessionid")
    if not sessionid:
        raise HTTPException(status_code=400, detail="Missing sessionid")

    tags = data.get("tags") or []
    contact = data.get("contact") or None
    sourcelink = data.get("sourcelink") or None
    documenttitle = data.get("documenttitle") or None
    validatorid = data.get("validatorid") or None
    severity = data.get("severity") or None

    try:
        srow = (
            supabase.table("sessions")
            .select("docid")
            .eq("id", sessionid)
            .maybe_single()
            .execute()
            .data
            or {}
        )
        docid = srow.get("docid")
        if not docid:
            raise HTTPException(
                status_code=404, detail="Session not found or missing docid"
            )

        upd: Dict[str, Any] = {
            "tags": tags,
            "employeecontact": contact,
            "link": sourcelink,
            "responsible": validatorid,
            "severitylevels": severity,
            "status": "Pending",
        }
        if documenttitle:
            upd["title"] = documenttitle

        supabase.table("documents").update(upd).eq("docid", docid).execute()
        supabase.table("sessions").update({"status": "Completed"}).eq(
            "id", sessionid
        ).execute()

        return {"message": "Document stored successfully"}
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))
