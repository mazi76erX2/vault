"""
main.py - FastAPI Application Entry Point
Updated for Ollama + Qdrant + pgvector stack
Local-first architecture for knowledge management
Migration completed: December 2025
"""

import base64
import logging
import os
import random
import string
from contextlib import asynccontextmanager
from datetime import datetime

import uvicorn
from fastapi import (
    APIRouter,
    Depends,
    FastAPI,
    HTTPException,
    WebSocket,
    WebSocketDisconnect,
    status,
)
from fastapi.middleware.cors import CORSMiddleware
from fastapi.responses import FileResponse
from gotrue.types import UserResponse
from pydantic import BaseModel, EmailStr

import app.email_service as email_service
from app.api.auth import router as auth_router
# from app.api.collector import router as collector_router TODO: Migrate to SQLaclhemy
# from app.api.expert import router as expert_router
# from app.api.helper import router as helper_router
# from app.api.validator import router as validator_router
from app.connection_manager import connection_manager
from app.connectors.store_data_in_kb import store_in_kb
from app.constants.constants import SEVERITY_LEVEL_MAP
from app.email_service import send_welcome_email
# from app.ldap import router as ldap_router
from app.logger_config import setup_logging  # Import the logging setup
from app.middleware.auth import verify_token, verify_token_with_tenant
from app.services.auth_service import get_current_user
from app.services.tenant_service import TenantService

# from app.schemas.user import UserBase

ws_router = APIRouter()

# Initialize logging before importing other modules
setup_logging()

logger = logging.getLogger(__name__)
UPLOAD_DIR = os.getenv("UPLOAD_DIR", "./uploads")


def ensure_storage_bucket_exists(bucket_name: str) -> bool:
    """
    Ensure that a storage bucket exists in Supabase, create it if it doesn't.

    Args:
        bucket_name: The name of the bucket to check/create

    Returns:
        bool: True if bucket exists or was created successfully, False otherwise
    """
    try:
        # Check if bucket exists
        try:
            bucket_info = supabase_admin.storage.get_bucket(bucket_name)
            if bucket_info:
                logger.info(f"Storage bucket '{bucket_name}' already exists.")
                return True
        except Exception:
            # Bucket doesn't exist, we'll try to create it
            logger.info(f"Storage bucket '{bucket_name}' doesn't exist, will create it.")

        # Create the bucket
        try:
            create_result = supabase_admin.storage.create_bucket(bucket_name, {"public": True})
            if create_result:
                logger.info(f"Successfully created storage bucket '{bucket_name}'.")
                return True
        except Exception as create_error:
            error_msg = str(create_error).lower()
            if "409" in error_msg or "duplicate" in error_msg or "already exists" in error_msg:
                logger.info(f"Bucket '{bucket_name}' already exists.")
                return True
            else:
                logger.error(f"Failed to create bucket '{bucket_name}': {create_error}")
                return False

        return True

    except Exception as e:
        logger.error(f"Unexpected error in bucket check for '{bucket_name}': {e}")
        return False


@asynccontextmanager
async def lifespan(app: FastAPI):
    # Run on app startup
    logger.info("Application startup: Logging system initialized.")
    yield
    # Run on app shutdown
    logger.info("Application shutdown: Logging system finalized.")


app = FastAPI(lifespan=lifespan)
app.include_router(auth_router)
# app.include_router(collector_router)
# app.include_router(helper_router)
# app.include_router(validator_router)
# app.include_router(expert_router)
# app.include_router(ldap_router)


# Role-based access dependency
def require_roles(roles: list[str]):
    """
    Decorator to check if the current user has the required roles.
    """

    def role_checker(current_user=Depends(get_current_user)):
        user_roles = getattr(current_user, "roles", [])
        if not any(r in user_roles for r in roles):
            raise HTTPException(
                status_code=status.HTTP_403_FORBIDDEN, detail="Insufficient privileges"
            )
        return current_user

    return role_checker


app.include_router(collector_router, dependencies=[Depends(require_roles(["Collector"]))])
app.include_router(helper_router, dependencies=[Depends(require_roles(["Helper"]))])
app.include_router(ldap_router, dependencies=[Depends(require_roles(["Administrator"]))])


origins = [
    "http://localhost:8081",  # Vite default port
    "http://localhost:3000",  # Common React port
    "http://81.28.6.125:8000",
    "http://localhost:8082",
    "https://vaulttesting.highcoordination.de",
    "https://demovault.highcoordination.de",
]
app.add_middleware(
    CORSMiddleware,
    allow_origins=origins,
    allow_credentials=True,
    allow_methods=["GET", "POST", "PUT", "DELETE", "OPTIONS"],
    allow_headers=[
        "Content-Type",
        "Authorization",
        "Accept",
        "Origin",
        "X-Requested-With",
    ],
    expose_headers=["Content-Type", "Authorization"],
    max_age=3600,
)

manager = connection_manager()
app.include_router(ws_router)


@app.websocket("/ws/{client_id}")
async def websocket_endpoint(websocket: WebSocket, client_id: str):
    await manager.connect(client_id, websocket)
    try:
        while True:
            data = await websocket.receive_text()
            await manager.send_personal_message(client_id, f"You wrote: {data}")
            await manager.broadcast(f"Client {client_id} says: {data}")
    except WebSocketDisconnect:
        await manager.disconnect(client_id, websocket)
        await manager.broadcast(f"Client {client_id} left the chat")


@app.post("/api/console/store_in_kb")
def store_knowledge(data: dict):
    document_id = data.get("doc_id")
    logger.info("Received document id: %s", document_id)
    response = supabase.table("documents").select("*").eq("doc_id", document_id).execute()
    documents = response.data
    logger.info("Received document : %s", response.data)

    response_message = ""

    if documents:  # Ensure data was returned
        # Retrieve the 'summary' column value (assuming only one document is returned)
        document = documents[0]
        summary_values = document.get("summary", "N/A")
        severity_levels = document.get("severity_levels", "N/A")
        title = document.get("title", "N/A")
        link = document.get("link", "N/A")
        severity_level_int = SEVERITY_LEVEL_MAP.get(severity_levels, 1)
        doc_to_store = {
            "file_name": link,
            "content": summary_values,
            "file_title": title,
            "level": severity_level_int,
        }
        store_in_kb(doc_to_store)
        response_message = "Document validated and stored in the Knowledge Base"

        logger.info("%s", response_message)

    else:
        response_message = "No documents found."

        logger.info("%s", response_message)

    return {"response": response_message}


@app.post("/api/feedback/thumbs_up")
def thumbs_up(data: dict):
    # Handle thumbs-up feedback
    pass


@app.post("/api/documents/upload")
def upload_document(doc_data: dict):
    # Save document metadata and content
    pass


@app.get("/api/documents")
def list_documents():
    # Return stored documents
    pass


@app.post("/api/chat/feedback")
def submit_feedback(user_feedback: dict):
    # Log feedback in your DB, or update RL model
    pass


# @app.post("/documents/assign")
# def assign_document(doc_id: int, reviewer_id: int, current_user: User = Depends(get_current_user),
#                     db: Session = Depends(get_db)):
#     # Check if user has manager or admin role
#     if current_user.role not in [RoleEnum.manager, RoleEnum.admin]:
#         raise HTTPException(status_code=403, detail="You are not allowed to assign documents.")

#     # Proceed with assignment logic
#     doc = db.query(Document).filter_by(doc_id=doc_id).first()
#     if not doc:
#         raise HTTPException(status_code=404, detail="Document not found.")

#     # Set doc's reviewer_id
#     doc.reviewer_id = reviewer_id
#     doc.status = "assigned"
#     db.commit()
#     return {"detail": "Document assigned successfully."}

# @app.post("/documents/validate")
# def validate_document(doc_id: int, current_user: User = Depends(get_current_user), db: Session = Depends(get_db)):
#     # Check if user has reviewer or admin role
#     if current_user.role not in [RoleEnum.reviewer, RoleEnum.admin]:
#         raise HTTPException(status_code=403, detail="You are not allowed to validate documents.")

#     doc = db.query(Document).filter_by(doc_id=doc_id).first()
#     if not doc:
#         raise HTTPException(status_code=404, detail="Document not found.")

#     # Proceed with validation logic
#     doc.status = "validated"
#     db.commit()
#     return {"detail": "Document validated successfully."}


@app.get("/download-logs", response_class=FileResponse)
def download_logs():
    """
    Endpoint to download the backend log file.
    """
    return FileResponse("backend_logs.log", media_type="text/plain", filename="backend_logs.log")


@app.get("/api/users/departments")
def get_departments():
    """
    Endpoint to departments enumerated type from supabase.
    """
    logger.info("Getting departments from supabase")
    departments_response = supabase.rpc("get_enum_values", {"enum_name": "department"}).execute()
    departments_data = departments_response.data
    logger.info("departments: %s", departments_data)
    return departments_data


# ConsoleMainPage - get validator flag
class UserInfo(BaseModel):
    user_id: str
    is_validator: bool
    is_expert: bool


@app.get("/api/console-main/user-info/{user_id}", response_model=UserInfo)
async def console_main_get_user_info(user_id: str):
    try:
        validator_response = (
            supabase.from_("profiles")
            .select("isValidator")
            .eq("id", user_id)
            .maybe_single()
            .execute()
        )
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Error fetching validator flag: {str(e)}")

    try:
        documents_response = (
            supabase.from_("documents").select("doc_id").eq("reviewer", user_id).execute()
        )
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Error fetching documents: {str(e)}")

    is_validator = validator_response.data["isValidator"] if validator_response.data else False
    is_expert = len(documents_response.data) > 0 if documents_response.data else False

    return UserInfo(user_id=user_id, is_validator=is_validator, is_expert=is_expert)


# AdminsPage - get users
@app.get("/api/admin/users")
def admin_get_users(current_user=Depends(verify_token_with_tenant)):
    try:
        logger.info("admin_get_users endpoint called with tenant-aware authentication")

        # Get the user's company registration number from the token
        company_reg_no = getattr(current_user, "company_reg_no", None)
        if not company_reg_no:
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail="User company association not found",
            )

        logger.info(f"Fetching users for tenant: {company_reg_no}")

        # 1. Fetch all profiles for this tenant only
        profiles_data = TenantService.get_tenant_profiles(company_reg_no)

        if not profiles_data:
            return []

        user_ids = [profile["id"] for profile in profiles_data]

        # 2. Fetch all roles defined in the system
        all_roles_response = supabase.table("roles").select("id, name").execute()
        role_name_to_id_map = {}
        if all_roles_response.data:
            {role["id"]: role["name"] for role in all_roles_response.data}
            role_name_to_id_map = {role["name"]: role["id"] for role in all_roles_response.data}
        else:
            logger.warning("No roles found in the roles table.")

        # 3. Fetch user_roles for all users in this tenant
        user_roles_response = (
            supabase.table("user_roles")
            .select("user_id, role_id")
            .in_("user_id", user_ids)
            .eq("company_reg_no", company_reg_no)  # Ensure tenant isolation
            .execute()
        )
        user_roles_assignments = {}
        if user_roles_response.data:
            for assignment in user_roles_response.data:
                user_id_key = assignment["user_id"]
                role_id = assignment["role_id"]
                if user_id_key not in user_roles_assignments:
                    user_roles_assignments[user_id_key] = []
                user_roles_assignments[user_id_key].append(role_id)

        # 4. Augment profiles_data with role booleans and company registered_since
        augmented_users = []
        for profile in profiles_data:
            user_id = profile["id"]
            assigned_role_ids = user_roles_assignments.get(user_id, [])

            profile["is_admin"] = role_name_to_id_map.get("Administrator") in assigned_role_ids
            profile["is_validator"] = profile.get("isValidator", False) or (
                role_name_to_id_map.get("Validator") in assigned_role_ids
            )
            profile["is_expert"] = role_name_to_id_map.get("Expert") in assigned_role_ids
            profile["is_collector"] = role_name_to_id_map.get("Collector") in assigned_role_ids
            profile["is_helper"] = role_name_to_id_map.get("Helper") in assigned_role_ids

            # Get registered_since from the profile
            profile["registered_since"] = profile.get("created_at")
            profile["security_level"] = profile.get("user_access")

            augmented_users.append(profile)

        logger.info(f"Returning {len(augmented_users)} users for tenant {company_reg_no}")
        return augmented_users

    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Error in admin_get_users: {str(e)}", exc_info=True)
        raise HTTPException(status_code=500, detail=f"Error fetching users: {str(e)}")


@app.post("/api/user/profile")
async def get_user_profile(data: dict, current_user=Depends(verify_token_with_tenant)):
    try:
        user_id = data.get("user_id")
        if not user_id:
            raise HTTPException(status_code=400, detail="user_id is required")

        # Get the user's company registration number from the token
        company_reg_no = getattr(current_user, "company_reg_no", None)
        if not company_reg_no:
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail="User company association not found",
            )

        # Fetch the user's profile using tenant-aware method
        profile_data = TenantService.get_tenant_profile(user_id, company_reg_no)

        if not profile_data:
            raise HTTPException(status_code=404, detail="User profile not found")

        # Return only safe profile data
        safe_profile_data = {
            "id": profile_data.get("id"),
            "full_name": profile_data.get("full_name"),
            "email": profile_data.get("email"),
            "telephone": profile_data.get("telephone"),
            "company_name": profile_data.get("company_name"),
        }

        return {"profile": safe_profile_data}
    except HTTPException:
        raise
    except Exception as e:
        logging.error("Error fetching user profile: %s", str(e))
        raise HTTPException(status_code=500, detail=f"Error fetching user profile: {str(e)}") from e


class UserCompanyRequest(BaseModel):
    """Request schema for get_user_company"""

    user_id: str


# Response schema for get_user_company
class CompanyDetails(BaseModel):
    """Response schema for get_user_company"""

    id: str
    name: str
    registered_since: str


class GetUserCompanyResponse(BaseModel):
    """Response schema for get_user_company"""

    company: CompanyDetails


@app.post("/api/user/company", response_model=GetUserCompanyResponse)
async def get_user_company(
    request: UserCompanyRequest, current_user=Depends(verify_token_with_tenant)
):
    """Get the company details for an admin user."""
    user_id = request.user_id
    if not user_id:
        raise HTTPException(status_code=400, detail="user_id is required")

    try:
        # Get the user's company registration number from the token
        company_reg_no = getattr(current_user, "company_reg_no", None)
        if not company_reg_no:
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail="User company association not found",
            )

        # Validate that the requested user belongs to the same tenant
        profile = TenantService.get_tenant_profile(user_id, company_reg_no)
        if not profile:
            raise HTTPException(
                status_code=404,
                detail="User has no associated company or access denied",
            )

        company_id = profile.get("company_id")
        if not company_id:
            raise HTTPException(status_code=404, detail="User has no associated company")

        company = (
            supabase.table("companies")
            .select("id", "name", "registered_since")
            .eq("id", company_id)
            .eq("company_reg_no", company_reg_no)  # Ensure tenant isolation
            .single()
            .execute()
            .data
        )

        if not company:
            raise HTTPException(status_code=404, detail="Company not found")

        name = profile.get("company_name") or company["name"]

        if not profile.get("company_name"):
            try:
                TenantService.update_tenant_profile(
                    user_id,
                    {"company_name": name, "updated_at": datetime.now().isoformat()},
                    company_reg_no,
                )
                logger.info("Updated profile for user %s with company name %s", user_id, name)
            except Exception as err:
                logger.warning("Failed to update profile for user %s: %s", user_id, err)

        company["name"] = name
        # Convert company ID to string
        company["id"] = str(company["id"])
        return {"company": company}
    except HTTPException:
        raise
    except Exception as e:
        logger.error("Error fetching user company: %s", e)
        raise HTTPException(status_code=500, detail="Error fetching user company") from e


class OrganisationDetails(BaseModel):
    """Organisation details model."""

    firstName: str
    lastName: str
    email: str
    telephone: str
    company: str
    registeredSince: str
    user_id: str | None = None


# Request schema for update_user_details
class UpdateUserDetailsRequest(BaseModel):
    """Request schema for update_user_details"""

    firstName: str
    lastName: str
    email: EmailStr
    telephone: str
    company: str
    user_id: str | None = None
    username: str | None = None
    roles: list[str] | None = None


@app.post("/api/user/update_user_details", response_model=OrganisationDetails)
async def update_user_details(
    request: UpdateUserDetailsRequest,
    current_user: UserResponse = Depends(verify_token_with_tenant),
):
    """Update or add user details. Only accessible by users with the Administrator role."""
    try:
        # Get the user's company registration number from the token
        company_reg_no = getattr(current_user, "company_reg_no", None)
        if not company_reg_no:
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail="User company association not found",
            )

        # --- Admin Check - Updated to use tenant-aware role-based authentication ---
        try:
            # Get current user's roles from user_roles table (tenant-scoped)
            user_roles_response = (
                supabase.table("user_roles")
                .select("role_id")
                .eq("user_id", current_user.user.id)
                .eq("company_reg_no", company_reg_no)  # Ensure tenant scope
                .execute()
            )

            user_role_ids = (
                [ur["role_id"] for ur in user_roles_response.data]
                if user_roles_response.data
                else []
            )

            # Get Administrator role ID
            admin_role_response = (
                supabase.table("roles").select("id").eq("name", "Administrator").execute()
            )

            if not admin_role_response.data:
                logger.error("Administrator role not found in roles table")
                raise HTTPException(
                    status_code=500,
                    detail="System error: Administrator role not configured.",
                )

            admin_role_id = admin_role_response.data[0]["id"]

            # Check if user has Administrator role within this tenant
            if admin_role_id not in user_role_ids:
                logger.warning(
                    f"User {current_user.user.email} (ID: {current_user.user.id}) "
                    f"attempted to access admin endpoint without Administrator role in tenant {company_reg_no}."
                )
                raise HTTPException(
                    status_code=403,
                    detail="User does not have permission to perform this action. Administrator role required.",
                )

            logger.info(
                f"Admin user {current_user.user.email} accessing update_user_details for tenant {company_reg_no}."
            )
        except HTTPException:
            raise
        except Exception as role_check_error:
            logger.error(f"Error checking user roles: {role_check_error}")
            raise HTTPException(status_code=500, detail="Error verifying user permissions.")
        # --- End Admin Check ---

        current_date = datetime.now().isoformat()

        first_name = request.firstName
        last_name = request.lastName
        requested_company_name = request.company
        user_id_from_request = request.user_id
        email = request.email
        telephone = request.telephone
        requested_username = request.username
        requested_roles = request.roles

        # For tenant-aware operations, we'll use the company_reg_no instead of company_id
        db_company_id_for_profile = None  # Keep this null for now
        response_registered_since = current_date

        logger.info(
            f"Processing user update/creation for tenant {company_reg_no}. Company name: '{requested_company_name}'."
        )

        db_user_id = None
        is_existing_profile = False

        if user_id_from_request:
            # Check if profile exists within this tenant
            existing_profile = TenantService.get_tenant_profile(
                user_id_from_request, company_reg_no
            )
            if existing_profile:
                is_existing_profile = True
                db_user_id = existing_profile["id"]

                # Check email uniqueness within tenant
                if email != existing_profile["email"]:
                    tenant_profiles = TenantService.get_tenant_profiles(company_reg_no)
                    for profile in tenant_profiles:
                        if profile["email"] == email and profile["id"] != db_user_id:
                            raise HTTPException(
                                status_code=400,
                                detail=f"Email '{email}' is already in use by another user in your organization.",
                            )

                # Check username uniqueness within tenant
                if requested_username and requested_username != existing_profile.get("username"):
                    for profile in tenant_profiles:
                        if (
                            profile.get("username") == requested_username
                            and profile["id"] != db_user_id
                        ):
                            raise HTTPException(
                                status_code=400,
                                detail=f"Username '{requested_username}' is already taken in your organization.",
                            )
            else:
                raise HTTPException(
                    status_code=404,
                    detail=f"User with ID '{user_id_from_request}' not found in your organization.",
                )
        else:
            # Check if email exists within tenant
            tenant_profiles = TenantService.get_tenant_profiles(company_reg_no)
            for profile in tenant_profiles:
                if profile["email"] == email:
                    is_existing_profile = True
                    db_user_id = profile["id"]

                    # Check username uniqueness within tenant
                    if requested_username and requested_username != profile.get("username"):
                        for other_profile in tenant_profiles:
                            if (
                                other_profile.get("username") == requested_username
                                and other_profile["id"] != db_user_id
                            ):
                                raise HTTPException(
                                    status_code=400,
                                    detail=f"Username '{requested_username}' is already taken in your organization.",
                                )
                    break

            if not is_existing_profile:
                # Generate username if not provided
                if requested_username:
                    # Check username uniqueness within tenant
                    for profile in tenant_profiles:
                        if profile.get("username") == requested_username:
                            raise HTTPException(
                                status_code=400,
                                detail=f"Username '{requested_username}' is already taken in your organization.",
                            )
                else:
                    base_username = f"{first_name.lower().replace(' ', '')}_{last_name.lower().replace(' ', '')}{random.randint(100, 999)}"
                    requested_username = base_username
                    while any(
                        profile.get("username") == requested_username for profile in tenant_profiles
                    ):
                        requested_username = f"{first_name.lower().replace(' ', '')}_{last_name.lower().replace(' ', '')}{random.randint(100, 999)}"

        profile_data_to_update = {
            "full_name": f"{first_name} {last_name}",
            "email": email,
            "telephone": telephone,
            "company_id": db_company_id_for_profile,
            "company_name": requested_company_name,
            "company_reg_no": company_reg_no,  # Ensure tenant association
            "updated_at": current_date,
        }
        if requested_username:
            profile_data_to_update["username"] = requested_username

        # Validate required fields
        required_fields_check = {
            "email": profile_data_to_update["email"],
            "full_name": profile_data_to_update["full_name"],
            "telephone": profile_data_to_update["telephone"],
            "company_name": profile_data_to_update["company_name"],
        }
        missing_fields = [
            field_name for field_name, value in required_fields_check.items() if not value
        ]
        if missing_fields:
            formatted_fields = [field.replace("_", " ") for field in missing_fields]
            missing_fields_str = ", ".join(formatted_fields)
            raise HTTPException(
                status_code=400,
                detail=f"The following fields are required for profile: {missing_fields_str}",
            )

        if is_existing_profile:
            if not db_user_id:
                raise HTTPException(
                    status_code=500,
                    detail="User ID missing for existing profile update.",
                )
            TenantService.update_tenant_profile(db_user_id, profile_data_to_update, company_reg_no)
            logger.info(f"Profile updated for user ID: {db_user_id} in tenant {company_reg_no}")
        else:
            # Create new user with tenant association
            password = "".join(random.choices(string.ascii_letters + string.digits, k=12))
            if not profile_data_to_update.get("username"):
                profile_data_to_update["username"] = requested_username

            try:
                auth_response = supabase_admin.auth.admin.create_user(
                    {
                        "email": email,
                        "password": password,
                        "user_metadata": {"full_name": profile_data_to_update["full_name"]},
                        "email_confirm": True,
                    }
                )
                db_user_id = auth_response.user.id
                profile_data_to_update["id"] = db_user_id

                # Create profile with tenant association
                TenantService.create_tenant_profile(profile_data_to_update, company_reg_no)
                logger.info(
                    f"Profile created for new user ID: {db_user_id} in tenant {company_reg_no}"
                )

                # Send welcome email
                username_for_email = profile_data_to_update.get("username")
                if not username_for_email:
                    logger.error(f"Username is unexpectedly None for new user {db_user_id}")
                    username_for_email = "User"

                await send_welcome_email(email, password, username_for_email)
            except Exception as e:
                if db_user_id:
                    try:
                        supabase_admin.auth.admin.delete_user(db_user_id)
                        logger.info(
                            f"Cleaned up auth user {db_user_id} due to profile creation failure."
                        )
                    except Exception as e_auth_delete:
                        logger.error(f"Failed to clean up auth user {db_user_id}: {e_auth_delete}")
                raise HTTPException(
                    status_code=500, detail=f"Error creating user account: {str(e)}"
                )

        # --- Role Handling (tenant-scoped) ---
        if db_user_id and requested_roles is not None:
            role_ids_to_assign = []
            if requested_roles:
                roles_from_db_response = (
                    supabase.table("roles")
                    .select("id, name")
                    .in_("name", requested_roles)
                    .execute()
                )
                if roles_from_db_response.data:
                    role_map = {role["name"]: role["id"] for role in roles_from_db_response.data}
                    for role_name in requested_roles:
                        if role_name in role_map:
                            role_ids_to_assign.append(role_map[role_name])
                        else:
                            logger.warning(
                                f"Role name '{role_name}' not found in database. Skipping."
                            )

            # Clear existing roles for this user in this tenant
            (
                supabase.table("user_roles")
                .delete()
                .eq("user_id", db_user_id)
                .eq("company_reg_no", company_reg_no)
                .execute()
            )
            logger.info(
                f"Cleared existing roles for user ID: {db_user_id} in tenant {company_reg_no}"
            )

            if role_ids_to_assign:
                user_roles_to_insert = [
                    {
                        "user_id": db_user_id,
                        "role_id": role_id,
                        "company_reg_no": company_reg_no,
                    }
                    for role_id in role_ids_to_assign
                ]
                (supabase.table("user_roles").insert(user_roles_to_insert).execute())
                logger.info(
                    f"Assigned new roles to user ID: {db_user_id} in tenant {company_reg_no} - Roles: {requested_roles}"
                )

        response_data = {
            "firstName": first_name,
            "lastName": last_name,
            "email": email,
            "telephone": telephone,
            "company": requested_company_name,
            "registeredSince": response_registered_since,
            "user_id": db_user_id,
        }
        return response_data

    except HTTPException:
        raise
    except Exception as e:
        logging.error("Error updating organisation details: %s", str(e))
        raise HTTPException(
            status_code=500, detail=f"Error updating organisation details: {str(e)}"
        ) from e


class DeleteUserResponse(BaseModel):
    """Response schema for delete user endpoint"""

    message: str


@app.delete(
    "/api/admin/users/{user_id}",
    status_code=200,
    response_model=DeleteUserResponse,
    dependencies=[Depends(require_roles(["Administrator"]))],
)
async def admin_users_delete(user_id: str):
    """Deletes a user from the system."""
    try:
        has_session = bool(
            supabase.from_("sessions").select("id").eq("user_id", user_id).limit(1).execute().data
        )
        if not has_session:
            # Hard delete
            try:
                supabase_admin.auth.admin.delete_user(user_id)
                logger.info("Deleted Auth user %s", user_id)
            except Exception as err:
                logger.error("Auth delete error for %s: %s", user_id, err)
            try:
                supabase.from_("profiles").delete().eq("id", user_id).execute()
                logger.info("Deleted profile %s", user_id)
            except Exception as err:
                logger.error("Profile delete error for %s: %s", user_id, err)
                raise HTTPException(
                    status_code=500, detail=f"Error deleting user profile: {err}"
                ) from err
            return {"message": f"User {user_id} permanently deleted."}

        # Soft delete
        exists = bool(supabase.from_("profiles").select("id").eq("id", user_id).execute().data)
        if not exists:
            logger.warning("Profile not found for %s", user_id)
        action = "deactivated"
        try:
            supabase_admin.auth.admin.update_user_by_id(
                user_id,
                {
                    "ban_duration": "none",
                    "email_confirm": False,
                    "user_metadata": {"status": "inactive"},
                },
            )
            logger.info("Deactivated auth user %s", user_id)
        except Exception as err:
            msg = str(err)
            if "not found" in msg and not exists:
                logger.warning("Auth user not found %s", user_id)
                return {"message": f"User {user_id} was not found, considered deleted."}
            logger.error("Auth update error for %s: %s", user_id, err)
            raise HTTPException(status_code=500, detail=f"Failed auth update: {err}") from err

        try:
            res = (
                supabase.from_("profiles")
                .update({"status": "inactive", "updated_at": datetime.now().isoformat()})
                .eq("id", user_id)
                .execute()
            )
            if res.data:
                logger.info("Marked profile inactive %s", user_id)
            else:
                logger.warning("No profile update for %s", user_id)
        except Exception as err:
            logger.critical("Profile update failed for %s: %s", user_id, err)
            raise HTTPException(
                status_code=500,
                detail=f"User was {action} in auth but failed to update profile: {err}",
            ) from err

        return {"message": f"User {user_id} successfully {action}."}

    except HTTPException:
        raise
    except Exception as err:
        logger.error("Unexpected error for %s: %s", user_id, err)
        raise HTTPException(status_code=500, detail=f"An unexpected error occurred: {err}") from err


class GetCompanyThemeSettingsRequest(BaseModel):
    """Request schema for get_company_theme_settings"""

    user_id: str


class CompanyThemeSettingsResponse(BaseModel):
    """Response schema for get_company_theme_settings"""

    id: str
    name: str
    user_chat_bubble_colour: str | None = None
    bot_chat_bubble_colour: str | None = None
    send_button_and_box: str | None = None
    font: str | None = None
    user_chat_font_colour: str | None = None
    bot_chat_font_colour: str | None = None
    logo: str | None = None
    bot_profile_picture: str | None = None


class GetCompanyThemeSettingsResponse(BaseModel):
    """Response schema for get_company_theme_settings"""

    status: str
    theme_settings: CompanyThemeSettingsResponse


def ensure_color_has_hash(color_value: str) -> str:
    """Ensure color value has # prefix if it's a valid color string."""
    if not color_value:
        return color_value
    if color_value.startswith("#"):
        return color_value
    # Add # prefix if it's a valid hex color (3 or 6 characters)
    if len(color_value) in [3, 6] and all(c in "0123456789ABCDEFabcdef" for c in color_value):
        return f"#{color_value}"
    return color_value


@app.post(
    "/api/v1/companies/get_theme_settings",
)
async def get_company_theme_settings(request: GetCompanyThemeSettingsRequest):
    try:
        user_id = request.user_id
        logger.info(f"Fetching theme settings for user ID: {user_id}")

        default_settings_response = {
            "status": "success",
            "theme_settings": {
                "id": "default",
                "name": "Default Company",
                "userChatBubbleColor": "#007bff",
                "botChatBubbleColor": "#e5e5ea",
                "sendButtonAndBox": "#ffffff",
                "font": "Tahoma",
                "userChatFontColor": "#000000",
                "botChatFontColor": "#000000",
                "logo": None,
                "botProfilePicture": None,
            },
        }

        company_id = None  # Initialize company_id
        try:
            profile_response = (
                supabase.table("profiles").select("company_id").eq("id", user_id).execute()
            )
            logger.info(f"Profile response: {profile_response}")

            if not profile_response.data or not profile_response.data[0].get("company_id"):
                logger.warning(
                    f"No profile or company ID found for user ID: {user_id}, returning defaults."
                )
                return default_settings_response

            company_id = profile_response.data[0]["company_id"]
            logger.info(f"Company ID: {company_id}")
        except Exception as profile_error:
            logger.error(f"Error fetching user profile for {user_id}: {profile_error}")
            return default_settings_response

        company_data = None
        company_name = None
        try:
            company_response = (
                supabase.table("companies")
                .select(
                    "id, name, user_chat_bubble_colour, bot_chat_bubble_colour, "
                    "send_button_and_box, font, user_chat_font_colour, bot_chat_font_colour, "
                    "logo, bot_profile_picture"
                )
                .eq("id", company_id)
                .execute()
            )
            logger.info(f"Company response: {company_response}")

            if not company_response.data:
                logger.warning(
                    f"No company found for company ID: {company_id}, returning defaults with company ID."
                )
                default_settings_with_id = {
                    "id": str(company_id),
                    "name": "Unknown Company",
                    "userChatBubbleColor": "#007bff",
                    "botChatBubbleColor": "#e5e5ea",
                    "sendButtonAndBox": "#ffffff",
                    "font": "Tahoma",
                    "userChatFontColor": "#000000",
                    "botChatFontColor": "#000000",
                    "logo": None,
                    "botProfilePicture": None,
                }
                return {"status": "success", "theme_settings": default_settings_with_id}

            company_data = company_response.data[0]
            company_name = company_data.get("name", "")
            logger.info(f"Company name: {company_name}")

            company_data["id"] = str(company_data["id"])
            if company_data.get("user_chat_font_colour") is None:
                company_data["user_chat_font_colour"] = "#000000"
            if company_data.get("bot_chat_font_colour") is None:
                company_data["bot_chat_font_colour"] = "#000000"
            company_data["user_chat_bubble_colour"] = (
                company_data.get("user_chat_bubble_colour") or "#007bff"
            )
            company_data["bot_chat_bubble_colour"] = (
                company_data.get("bot_chat_bubble_colour") or "#e5e5ea"
            )
            company_data["send_button_and_box"] = (
                company_data.get("send_button_and_box") or "#ffffff"
            )
            company_data["font"] = company_data.get("font") or "Tahoma"

            logo_url = None
            bot_profile_url = None

            db_logo_path = company_data.get("logo")
            if db_logo_path and company_name:
                try:
                    # Use "companies" bucket with folder structure
                    bucket_name = "companies"
                    company_folder = company_name.lower().replace(" ", "_")
                    logo_response_url = supabase_admin.storage.from_(bucket_name).get_public_url(
                        f"{company_folder}/logo.png"
                    )
                    if logo_response_url:
                        logo_url = logo_response_url
                        logger.info(f"Logo URL: {logo_url}")
                except Exception as logo_error:
                    logger.warning(
                        f"Error generating or invalid logo URL for company {company_name}, path {db_logo_path}: {logo_error}"
                    )

            db_bot_profile_path = company_data.get("bot_profile_picture")
            if db_bot_profile_path and company_name:
                try:
                    # Use "companies" bucket with folder structure
                    bucket_name = "companies"
                    company_folder = company_name.lower().replace(" ", "_")
                    bot_profile_response_url = supabase_admin.storage.from_(
                        bucket_name
                    ).get_public_url(f"{company_folder}/bot_profile_picture.png")
                    if bot_profile_response_url:
                        bot_profile_url = bot_profile_response_url
                        logger.info(f"Bot profile URL: {bot_profile_url}")
                except Exception as profile_error_url:
                    logger.warning(
                        f"Error generating or invalid bot profile picture URL for company {company_name}, path {db_bot_profile_path}: {profile_error_url}"
                    )

            company_data["logo"] = logo_url
            company_data["bot_profile_picture"] = bot_profile_url

        except Exception as company_error:
            logger.error(f"Error fetching company {company_id}: {company_error}")
            default_settings_with_id_on_error = {
                "id": str(company_id) if company_id else "default-error",
                "name": "Error Company",
                "userChatBubbleColor": "#007bff",
                "botChatBubbleColor": "#e5e5ea",
                "sendButtonAndBox": "#ffffff",
                "font": "Tahoma",
                "userChatFontColor": "#000000",
                "botChatFontColor": "#000000",
                "logo": None,
                "botProfilePicture": None,
            }
            return {
                "status": "success",
                "theme_settings": default_settings_with_id_on_error,
            }

        # Transform property names to match frontend expectations (camelCase)
        transformed_data = {
            "id": company_data.get("id"),
            "name": company_data.get("name"),
            "userChatBubbleColor": ensure_color_has_hash(
                company_data.get("user_chat_bubble_colour")
            ),
            "botChatBubbleColor": ensure_color_has_hash(company_data.get("bot_chat_bubble_colour")),
            "sendButtonAndBox": ensure_color_has_hash(company_data.get("send_button_and_box")),
            "font": company_data.get("font"),
            "userChatFontColor": ensure_color_has_hash(company_data.get("user_chat_font_colour")),
            "botChatFontColor": ensure_color_has_hash(company_data.get("bot_chat_font_colour")),
            "logo": company_data.get("logo"),
            "botProfilePicture": company_data.get("bot_profile_picture"),
        }

        return {"status": "success", "theme_settings": transformed_data}
    except HTTPException as http_ex:
        logger.error(f"HTTP Exception in get_company_theme_settings: {http_ex.detail}")
        raise
    except Exception as e:
        logger.error(f"Unexpected error in get_company_theme_settings: {str(e)}")
        safe_default_theme_settings = CompanyThemeSettingsResponse(
            id="default_error",
            name="Error Company",
            user_chat_bubble_colour="#007bff",
            bot_chat_bubble_colour="#e5e5ea",
            send_button_and_box="#ffffff",
            font="Tahoma",
            user_chat_font_colour="#000000",
            bot_chat_font_colour="#000000",
            logo=None,
            bot_profile_picture=None,
        )
        return GetCompanyThemeSettingsResponse(
            status="error", theme_settings=safe_default_theme_settings
        )


class CompanyThemeSettingsPayload(BaseModel):
    """Request schema for update_company_theme_settings"""

    user_chat_bubble_colour: str | None = None
    bot_chat_bubble_colour: str | None = None
    send_button_and_box: str | None = None
    font: str | None = None
    user_chat_font_colour: str | None = None
    bot_chat_font_colour: str | None = None
    logo: str | None = None
    bot_profile_picture: str | None = None


class UpdateCompanyThemeSettingsRequest(BaseModel):
    user_id: str
    theme_settings: CompanyThemeSettingsPayload


@app.post("/api/v1/companies/update_theme_settings")
async def update_company_theme_settings(
    request_data: UpdateCompanyThemeSettingsRequest,
):
    """Update the theme settings for a company."""
    try:
        user_id = request_data.user_id
        theme_settings = request_data.theme_settings

        logger.info(f"Updating theme settings for user ID: {user_id}")

        if not user_id or not theme_settings:
            raise HTTPException(
                status_code=400,
                detail="Missing required fields: user_id or theme_settings",
            )

        profile_response = (
            supabase.table("profiles").select("company_id").eq("id", user_id).execute()
        )

        if not profile_response.data or not profile_response.data[0].get("company_id"):
            raise HTTPException(
                status_code=404, detail="User profile or company association not found"
            )

        company_id = profile_response.data[0]["company_id"]

        company_response = supabase.table("companies").select("name").eq("id", company_id).execute()

        if not company_response.data:
            raise HTTPException(status_code=404, detail="Company not found")

        company_name = company_response.data[0].get("name")
        if not company_name:
            raise HTTPException(
                status_code=500, detail="Company name not found for the company ID."
            )

        update_payload_for_db = {}

        # Handle text-based settings
        text_settings_map = {
            "user_chat_bubble_colour": theme_settings.user_chat_bubble_colour,
            "bot_chat_bubble_colour": theme_settings.bot_chat_bubble_colour,
            "send_button_and_box": theme_settings.send_button_and_box,
            "font": theme_settings.font,
            "user_chat_font_colour": theme_settings.user_chat_font_colour,
            "bot_chat_font_colour": theme_settings.bot_chat_font_colour,
        }
        for key, value in text_settings_map.items():
            if key in theme_settings.model_fields_set and value is not None:
                update_payload_for_db[key] = value
            elif key in theme_settings.model_fields_set and value is None:  # Explicitly set to null
                update_payload_for_db[key] = None

        # Handle Logo
        if "logo" in theme_settings.model_fields_set:
            logo_data = theme_settings.logo
            if logo_data and logo_data.startswith("data:image"):
                try:
                    bucket_name = "companies"
                    company_folder = company_name.lower().replace(" ", "_")
                    if not ensure_storage_bucket_exists(bucket_name):
                        raise HTTPException(
                            status_code=500,
                            detail=f"Failed to create or access storage bucket: {bucket_name}",
                        )

                    image_format, logo_base64 = logo_data.split(";base64,")
                    logo_binary = base64.b64decode(logo_base64)
                    storage_path = f"{company_folder}/logo.png"

                    supabase_admin.storage.from_(bucket_name).upload(
                        storage_path,
                        logo_binary,
                        {"content-type": "image/png", "upsert": "true"},
                    )
                    update_payload_for_db["logo"] = storage_path
                    logger.info(f"Logo uploaded successfully for company {company_name}")
                except Exception as upload_error:
                    logger.error(f"Error uploading logo: {upload_error}")
                    raise HTTPException(
                        status_code=500,
                        detail=f"Error uploading logo: {str(upload_error)}",
                    )
            elif logo_data is None:
                update_payload_for_db["logo"] = None

        # Handle Bot Profile Picture
        if "bot_profile_picture" in theme_settings.model_fields_set:
            bot_pic_data = theme_settings.bot_profile_picture
            logger.info(
                f"Bot profile picture processing: received data type: {type(bot_pic_data)}, starts with data:image: {bot_pic_data and bot_pic_data.startswith('data:image') if bot_pic_data else 'None'}"
            )

            if bot_pic_data and bot_pic_data.startswith("data:image"):
                try:
                    bucket_name = "companies"
                    company_folder = company_name.lower().replace(" ", "_")
                    logger.info(
                        f"Bot profile picture upload: bucket={bucket_name}, folder={company_folder}"
                    )

                    if not ensure_storage_bucket_exists(bucket_name):
                        raise HTTPException(
                            status_code=500,
                            detail=f"Failed to create or access storage bucket: {bucket_name}",
                        )

                    image_format, bot_pic_base64 = bot_pic_data.split(";base64,")
                    bot_pic_binary = base64.b64decode(bot_pic_base64)
                    storage_path = f"{company_folder}/bot_profile_picture.png"

                    logger.info(
                        f"Bot profile picture: uploading {len(bot_pic_binary)} bytes to {storage_path}"
                    )

                    supabase_admin.storage.from_(bucket_name).upload(
                        storage_path,
                        bot_pic_binary,
                        {"content-type": "image/png", "upsert": "true"},
                    )
                    update_payload_for_db["bot_profile_picture"] = storage_path
                    logger.info(
                        f"Bot profile picture uploaded successfully for company {company_name}"
                    )
                except Exception as upload_error:
                    logger.error(f"Error uploading bot profile picture: {upload_error}")
                    raise HTTPException(
                        status_code=500,
                        detail=f"Error uploading bot profile picture: {str(upload_error)}",
                    )
            elif bot_pic_data is None:
                logger.info(f"Bot profile picture set to None for company {company_name}")
                update_payload_for_db["bot_profile_picture"] = None
            else:
                logger.info(
                    f"Bot profile picture data invalid or empty for company {company_name}: {bot_pic_data[:100] if bot_pic_data else 'None'}"
                )
        else:
            logger.info(
                "Bot profile picture not in model_fields_set - no changes to bot profile picture"
            )

        if update_payload_for_db:
            (
                supabase.table("companies")
                .update(update_payload_for_db)
                .eq("id", company_id)
                .execute()
            )
            logger.info(f"Theme settings updated successfully for company {company_name}")
        else:
            logger.info(f"No changes to update for company {company_name}")

        return {
            "status": "success",
            "message": "Company theme settings updated successfully",
        }
    except HTTPException:
        raise
    except Exception as e:
        logger.error("Error updating company theme settings: %s", str(e))
        raise HTTPException(status_code=500, detail=str(e)) from e


class EmailTestRequest(BaseModel):
    """Request schema for test-email endpoint"""

    recipient_email: str
    subject: str | None = "Test Email from Vault"
    content: str | None = "This is a test email from the Vault application."
    username: str | None = None


@app.post("/api/utils/test-email")
async def test_email(request: EmailTestRequest):
    """
    Endpoint to test email sending functionality.

    This endpoint is used for testing the email service configuration and functionality.
    It allows developers to send a test email to verify that the email system is working properly.
    """
    try:
        # Ensure content is a string before length check or slicing
        email_content = request.content if request.content is not None else ""

        success = await email_service.send_test_email(
            email=request.recipient_email,
            subject=(request.subject if request.subject is not None else "Test Email from Vault"),
            content=email_content,  # Use the guaranteed string version
            username=request.username,
        )

        if success:
            logger.info("Test email sent successfully to %s", request.recipient_email)
            return {
                "status": "success",
                "message": f"Test email sent successfully to {request.recipient_email}",
                "details": {
                    "recipient": request.recipient_email,
                    "subject": (
                        request.subject if request.subject is not None else "Test Email from Vault"
                    ),
                    "content": (
                        email_content[:50] + "..." if len(email_content) > 50 else email_content
                    ),
                },
            }
        else:
            error_detail = email_service.LAST_EMAIL_ERROR or "unknown error"
            logger.error(
                "Failed to send test email to %s: %s",
                request.recipient_email,
                error_detail,
            )
            return {
                "status": "error",
                "message": f"Failed to send test email to {request.recipient_email}",
                "error": error_detail,
            }

    except Exception as e:
        logger.error("Error in test-email endpoint: %s", str(e))
        raise HTTPException(status_code=500, detail=f"Error sending test email: {str(e)}") from e


class PasswordResetRequestModel(BaseModel):
    """Request schema for reset-password-request endpoint"""

    email: EmailStr


class PasswordResetResponse(BaseModel):
    """Response schema for password reset endpoint"""

    status: str
    message: str


@app.post("/api/auth/reset-password-request", response_model=PasswordResetResponse)
async def request_password_reset(request: PasswordResetRequestModel):
    """Production-ready password reset endpoint using Supabase recovery link."""
    try:
        profile_resp = (
            supabase.from_("profiles").select("id").eq("email", request.email).single().execute()
        )
        if not profile_resp.data:
            return {
                "status": "success",
                "message": "If the email exists, a password reset link has been sent.",
            }

        redirect_url = os.getenv("PASSWORD_RESET_REDIRECT_URL", "")
        params = {
            "type": "recovery",
            "email": request.email,
            "redirectTo": redirect_url,
        }
        link_resp = supabase_admin.auth.admin.generate_link(params)
        if getattr(link_resp, "error", None):
            logger.error("Error generating reset link for %s: %s", request.email, link_resp.error)
            raise HTTPException(
                status_code=500, detail="Failed to generate password reset link"
            ) from link_resp.error
        action_link = link_resp.data.get("action_link") if link_resp.data else None
        if not action_link:
            logger.error("No action link returned for %s", request.email)
            raise HTTPException(status_code=500, detail="Failed to generate password reset link")

        await email_service.send_password_reset_email(request.email, action_link)
        logger.info("Sent password reset link to %s", request.email)
        return {
            "status": "success",
            "message": "Password reset instructions have been sent to your email",
        }

    except Exception as e:
        logger.error("Error in password reset request: %s", e)
        raise HTTPException(
            status_code=500, detail="Error processing password reset request"
        ) from e


class ChangePasswordModel(BaseModel):
    """Request schema for change-password endpoint"""

    user_id: str
    current_password: str
    new_password: str


@app.post("/api/auth/change-password")
async def change_password(request: ChangePasswordModel):
    """
    Endpoint for authenticated users to change their password.
    """
    try:
        profile = (
            supabase.from_("profiles")
            .select("email")
            .eq("id", request.user_id)
            .single()
            .execute()
            .data
        )
        if not profile or not profile.get("email"):
            raise HTTPException(status_code=404, detail="User not found for password change")
        email = profile["email"]
        auth_resp = supabase.auth.sign_in_with_password(
            {"email": email, "password": request.current_password}
        )
        if getattr(auth_resp, "error", None):
            logger.error("Authentication failed for %s: %s", request.user_id, auth_resp.error)
            raise HTTPException(
                status_code=401, detail="Current password is incorrect"
            ) from auth_resp.error

        supabase_admin.auth.admin.update_user_by_id(
            request.user_id, {"password": request.new_password}
        )

        supabase.from_("sessions").update(
            {"password_changed": True, "updated_at": datetime.now().isoformat()}
        ).eq("user_id", request.user_id).execute()

        logger.info("Password changed successfully for %s", request.user_id)
        return {"status": "success", "message": "Password changed successfully"}

    except HTTPException:
        raise
    except Exception as e:
        logger.error("Error changing password for %s: %s", request.user_id, e)
        raise HTTPException(status_code=500, detail="Error changing password") from e


class CheckFirstLoginModel(BaseModel):
    """Request schema for check-first-login endpoint"""

    user_id: str


@app.post("/api/auth/check-first-login")
async def check_first_login(request: CheckFirstLoginModel):
    """
    Endpoint to check if this is a user's first login and they need to change their password.
    """
    try:
        # Check for a session record for this user
        sessions_response = (
            supabase.from_("sessions")
            .select("id, password_changed")
            .eq("user_id", request.user_id)
            .order("created_at", desc=True)
            .limit(1)
            .execute()
        )

        # If no sessions or password never changed, this is effectively a first login
        if not sessions_response.data or not sessions_response.data[0].get(
            "password_changed", False
        ):
            # Optionally create a session if one doesn't exist
            if not sessions_response.data:
                supabase.from_("sessions").insert(
                    {
                        "user_id": request.user_id,
                        "status": "Started",
                        "password_changed": False,
                        "created_at": datetime.now().isoformat(),
                    }
                ).execute()

            return {
                "status": "success",
                "first_login": True,
                "require_password_change": True,
            }

        return {
            "status": "success",
            "first_login": False,
            "require_password_change": False,
        }

    except Exception as e:
        logger.error("Error checking first login status: %s", str(e))
        raise HTTPException(status_code=500, detail=f"Error checking login status: {str(e)}") from e


# app.mount("/", StaticFiles(directory="frontend/assets", html=True), name="static")


class CompanyContactDetails(BaseModel):
    """Company contact details model."""

    firstName: str
    lastName: str
    email: str
    telephone: str
    company: str
    registeredSince: str


class GetCompanyContactDetailsRequest(BaseModel):
    """Request schema for get_company_contact_details"""

    user_id: str


class UpdateCompanyContactDetailsRequest(BaseModel):
    """Request schema for update_company_contact_details"""

    user_id: str
    firstName: str
    lastName: str
    email: EmailStr
    telephone: str


@app.post("/api/company/contact_details", response_model=CompanyContactDetails)
async def get_company_contact_details(
    request: GetCompanyContactDetailsRequest,
    current_user: UserResponse = Depends(verify_token),
):
    """Get the company contact details for an admin user."""
    try:
        user_id = request.user_id
        if not user_id:
            raise HTTPException(status_code=400, detail="user_id is required")

        # Get user's company
        profile = (
            supabase.table("profiles")
            .select("company_id")
            .eq("id", user_id)
            .single()
            .execute()
            .data
        )

        if not profile or not profile.get("company_id"):
            raise HTTPException(status_code=404, detail="User has no associated company")

        company_id = profile["company_id"]

        # Get company details including contact information
        company = (
            supabase.table("companies")
            .select(
                "id",
                "name",
                "registered_since",
                "contact_first_name",
                "contact_last_name",
                "contact_email",
                "contact_telephone",
            )
            .eq("id", company_id)
            .single()
            .execute()
            .data
        )

        if not company:
            raise HTTPException(status_code=404, detail="Company not found")

        return CompanyContactDetails(
            firstName=company.get("contact_first_name") or "",
            lastName=company.get("contact_last_name") or "",
            email=company.get("contact_email") or "",
            telephone=company.get("contact_telephone") or "",
            company=company.get("name") or "",
            registeredSince=company.get("registered_since") or "",
        )

    except HTTPException:
        raise
    except Exception as e:
        logger.error("Error fetching company contact details: %s", e)
        raise HTTPException(status_code=500, detail="Error fetching company contact details") from e


@app.post("/api/company/update_contact_details", response_model=CompanyContactDetails)
async def update_company_contact_details(
    request: UpdateCompanyContactDetailsRequest,
    current_user: UserResponse = Depends(verify_token),
):
    """Update company contact details. Only accessible by users with the Administrator role."""
    try:
        # --- Admin Check ---
        try:
            # Get current user's roles from user_roles table
            user_roles_response = (
                supabase.table("user_roles")
                .select("role_id")
                .eq("user_id", current_user.user.id)
                .execute()
            )

            user_role_ids = (
                [ur["role_id"] for ur in user_roles_response.data]
                if user_roles_response.data
                else []
            )

            # Get Administrator role ID
            admin_role_response = (
                supabase.table("roles").select("id").eq("name", "Administrator").execute()
            )

            if not admin_role_response.data:
                logger.error("Administrator role not found in roles table")
                raise HTTPException(
                    status_code=500,
                    detail="System error: Administrator role not configured.",
                )

            admin_role_id = admin_role_response.data[0]["id"]

            # Check if user has Administrator role
            if admin_role_id not in user_role_ids:
                logger.warning(
                    f"User {current_user.user.email} (ID: {current_user.user.id}) "
                    f"attempted to update company contact details without Administrator role."
                )
                raise HTTPException(
                    status_code=403,
                    detail="User does not have permission to perform this action. Administrator role required.",
                )

            logger.info(f"Admin user {current_user.user.email} updating company contact details.")
        except HTTPException:
            raise
        except Exception as role_check_error:
            logger.error(f"Error checking user roles: {role_check_error}")
            raise HTTPException(status_code=500, detail="Error verifying user permissions.")

        user_id = request.user_id
        if not user_id:
            raise HTTPException(status_code=400, detail="user_id is required")

        # Get user's company
        profile = (
            supabase.table("profiles")
            .select("company_id")
            .eq("id", user_id)
            .single()
            .execute()
            .data
        )

        if not profile or not profile.get("company_id"):
            raise HTTPException(status_code=404, detail="User has no associated company")

        company_id = profile["company_id"]

        # Update company contact details
        update_data = {
            "contact_first_name": request.firstName,
            "contact_last_name": request.lastName,
            "contact_email": request.email,
            "contact_telephone": request.telephone,
        }

        supabase.table("companies").update(update_data).eq("id", company_id).execute()

        # Get updated company details to return
        company = (
            supabase.table("companies")
            .select(
                "id",
                "name",
                "registered_since",
                "contact_first_name",
                "contact_last_name",
                "contact_email",
                "contact_telephone",
            )
            .eq("id", company_id)
            .single()
            .execute()
            .data
        )

        if not company:
            raise HTTPException(status_code=404, detail="Company not found after update")

        logger.info(f"Company contact details updated for company ID: {company_id}")

        return CompanyContactDetails(
            firstName=company.get("contact_first_name", ""),
            lastName=company.get("contact_last_name", ""),
            email=company.get("contact_email", ""),
            telephone=company.get("contact_telephone", ""),
            company=company.get("name", ""),
            registeredSince=company.get("registered_since", ""),
        )

    except HTTPException:
        raise
    except Exception as e:
        logger.error("Error updating company contact details: %s", e)
        raise HTTPException(status_code=500, detail="Error updating company contact details") from e


if __name__ == "__main__":
    uvicorn.run(app, host="0.0.0.0", port=7860)
