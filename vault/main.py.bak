"""
main.py - FastAPI Application Entry Point
Fully migrated to SQLAlchemy + Cloudinary + Ollama + Qdrant
Local-first architecture for knowledge management
Migration completed: January 2026
"""

import logging
import os
import random
import string
from contextlib import asynccontextmanager
from datetime import datetime

import uvicorn
from fastapi import (
    APIRouter,
    Depends,
    FastAPI,
    HTTPException,
    WebSocket,
    WebSocketDisconnect,
    status,
)
from fastapi.middleware.cors import CORSMiddleware
from fastapi.responses import FileResponse
from pydantic import BaseModel, EmailStr
from sqlalchemy import select
from sqlalchemy.ext.asyncio import AsyncSession

import app.email_service as email_service
from app.api.auth import router as auth_router
from app.connection_manager import connection_manager
from app.connectors.store_data_in_kb import store_in_kb
from app.constants.constants import SEVERITY_LEVEL_MAP
from app.database import get_async_db
from app.db.enums import DepartmentEnum
from app.email_service import send_welcome_email
from app.logger_config import setup_logging
from app.middleware.auth import verify_token, verify_token_with_tenant
from app.models import Company, Document, Profile, Role, Session, User, UserRole
from app.services.auth_service import AuthService
from app.services.storage import StorageService
from app.services.tenant_service import TenantService

ws_router = APIRouter()

# Initialize logging
setup_logging()

logger = logging.getLogger(__name__)
UPLOAD_DIR = os.getenv("UPLOAD_DIR", "./uploads")


@asynccontextmanager
async def lifespan(app: FastAPI):
    """Application lifespan manager."""
    logger.info("Application startup: Logging system initialized.")
    yield
    logger.info("Application shutdown: Logging system finalized.")


app = FastAPI(lifespan=lifespan)
app.include_router(auth_router)


def require_roles(roles: list[str]):
    """Decorator to check if the current user has the required roles."""

    async def role_checker(
        current_user: dict = Depends(verify_token), db: AsyncSession = Depends(get_async_db)
    ):
        user_roles = current_user.get("roles", [])
        if not any(r in user_roles for r in roles):
            raise HTTPException(
                status_code=status.HTTP_403_FORBIDDEN, detail="Insufficient privileges"
            )
        return current_user

    return role_checker


origins = [
    "http://localhost:8081",
    "http://localhost:3000",
    "http://81.28.6.125:8000",
    "http://localhost:8082",
    "https://vaulttesting.highcoordination.de",
    "https://demovault.highcoordination.de",
]

app.add_middleware(
    CORSMiddleware,
    allow_origins=origins,
    allow_credentials=True,
    allow_methods=["GET", "POST", "PUT", "DELETE", "OPTIONS"],
    allow_headers=["Content-Type", "Authorization", "Accept", "Origin", "X-Requested-With"],
    expose_headers=["Content-Type", "Authorization"],
    max_age=3600,
)

manager = connection_manager()
app.include_router(ws_router)


# ==================== WEBSOCKET ====================


@app.websocket("/ws/{client_id}")
async def websocket_endpoint(websocket: WebSocket, client_id: str):
    """WebSocket endpoint for real-time communication."""
    await manager.connect(client_id, websocket)
    try:
        while True:
            data = await websocket.receive_text()
            await manager.send_personal_message(client_id, f"You wrote: {data}")
            await manager.broadcast(f"Client {client_id} says: {data}")
    except WebSocketDisconnect:
        await manager.disconnect(client_id, websocket)
        await manager.broadcast(f"Client {client_id} left the chat")


# ==================== KNOWLEDGE BASE ====================


@app.post("/api/console/store_in_kb")
async def store_knowledge(data: dict, db: AsyncSession = Depends(get_async_db)):
    """Store validated document in knowledge base."""
    document_id = data.get("doc_id")
    logger.info(f"Received document id: {document_id}")

    stmt = select(Document).where(Document.doc_id == document_id)
    result = await db.execute(stmt)
    document = result.scalar_one_or_none()

    if not document:
        logger.info("No documents found.")
        return {"response": "No documents found."}

    severity_level_int = SEVERITY_LEVEL_MAP.get(document.severity_levels, 1)
    doc_to_store = {
        "file_name": document.link,
        "content": document.summary or "N/A",
        "file_title": document.title,
        "level": severity_level_int,
    }
    store_in_kb(doc_to_store)

    logger.info("Document validated and stored in the Knowledge Base")
    return {"response": "Document validated and stored in the Knowledge Base"}


# ==================== UTILITY ENDPOINTS ====================


@app.get("/download-logs", response_class=FileResponse)
def download_logs():
    """Download backend log file."""
    return FileResponse("backend_logs.log", media_type="text/plain", filename="backend_logs.log")


@app.get("/api/users/departments")
async def get_departments():
    """Get all department enum values."""
    departments = [dept.value for dept in DepartmentEnum]
    logger.info(f"departments: {departments}")
    return departments


# ==================== USER INFO ====================


class UserInfo(BaseModel):
    user_id: str
    is_validator: bool
    is_expert: bool


@app.get("/api/console-main/user-info/{user_id}", response_model=UserInfo)
async def console_main_get_user_info(user_id: str, db: AsyncSession = Depends(get_async_db)):
    """Get user validation and expert status."""
    try:
        stmt = select(Profile.is_validator).where(Profile.id == user_id)
        result = await db.execute(stmt)
        is_validator = result.scalar_one_or_none() or False

        stmt = select(Document.doc_id).where(Document.reviewer == user_id).limit(1)
        result = await db.execute(stmt)
        is_expert = result.scalar_one_or_none() is not None

        return UserInfo(user_id=user_id, is_validator=is_validator, is_expert=is_expert)
    except Exception as e:
        logger.error(f"Error fetching user info: {e}")
        raise HTTPException(status_code=500, detail=f"Error fetching user info: {str(e)}")


# ==================== ADMIN ENDPOINTS ====================


@app.get("/api/admin/users")
async def admin_get_users(
    current_user: dict = Depends(verify_token_with_tenant), db: AsyncSession = Depends(get_async_db)
):
    """Get all users for tenant (admin only)."""
    try:
        logger.info("admin_get_users endpoint called with tenant-aware authentication")

        company_reg_no = current_user.get("company_reg_no")
        if not company_reg_no:
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail="User company association not found",
            )

        profiles = await TenantService.get_tenant_profiles(db, company_reg_no)

        if not profiles:
            return []

        user_ids = [str(profile["id"]) for profile in profiles]

        # Get all roles
        stmt = select(Role.id, Role.name)
        result = await db.execute(stmt)
        roles = result.all()
        role_name_to_id = {role.name: str(role.id) for role in roles}

        # Get user roles for this tenant
        stmt = select(UserRole.user_id, UserRole.role_id).where(
            UserRole.user_id.in_(user_ids), UserRole.company_reg_no == company_reg_no
        )
        result = await db.execute(stmt)
        user_role_rows = result.all()

        user_roles_map = {}
        for row in user_role_rows:
            user_id = str(row.user_id)
            if user_id not in user_roles_map:
                user_roles_map[user_id] = []
            user_roles_map[user_id].append(str(row.role_id))

        augmented_users = []
        for profile in profiles:
            user_id = str(profile["id"])
            assigned_role_ids = user_roles_map.get(user_id, [])

            profile["is_admin"] = role_name_to_id.get("Administrator") in assigned_role_ids
            profile["is_validator"] = profile.get("is_validator", False) or (
                role_name_to_id.get("Validator") in assigned_role_ids
            )
            profile["is_expert"] = role_name_to_id.get("Expert") in assigned_role_ids
            profile["is_collector"] = role_name_to_id.get("Collector") in assigned_role_ids
            profile["is_helper"] = role_name_to_id.get("Helper") in assigned_role_ids
            profile["registered_since"] = profile.get("created_at")
            profile["security_level"] = profile.get("user_access")

            augmented_users.append(profile)

        logger.info(f"Returning {len(augmented_users)} users for tenant {company_reg_no}")
        return augmented_users

    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Error in admin_get_users: {str(e)}", exc_info=True)
        raise HTTPException(status_code=500, detail=f"Error fetching users: {str(e)}")


# ==================== USER PROFILE ====================


@app.post("/api/user/profile")
async def get_user_profile(
    data: dict,
    current_user: dict = Depends(verify_token_with_tenant),
    db: AsyncSession = Depends(get_async_db),
):
    """Get user profile."""
    try:
        user_id = data.get("user_id")
        if not user_id:
            raise HTTPException(status_code=400, detail="user_id is required")

        company_reg_no = current_user.get("company_reg_no")
        if not company_reg_no:
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail="User company association not found",
            )

        profile_data = await TenantService.get_tenant_profile(db, user_id, company_reg_no)

        if not profile_data:
            raise HTTPException(status_code=404, detail="User profile not found")

        safe_profile_data = {
            "id": profile_data.get("id"),
            "full_name": profile_data.get("full_name"),
            "email": profile_data.get("email"),
            "telephone": profile_data.get("telephone"),
            "company_name": profile_data.get("company_name"),
        }

        return {"profile": safe_profile_data}
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Error fetching user profile: {str(e)}")
        raise HTTPException(status_code=500, detail=f"Error fetching user profile: {str(e)}") from e


# ==================== USER COMPANY ====================


class UserCompanyRequest(BaseModel):
    user_id: str


class CompanyDetails(BaseModel):
    id: str
    name: str
    registered_since: str


class GetUserCompanyResponse(BaseModel):
    company: CompanyDetails


@app.post("/api/user/company", response_model=GetUserCompanyResponse)
async def get_user_company(
    request: UserCompanyRequest,
    current_user: dict = Depends(verify_token_with_tenant),
    db: AsyncSession = Depends(get_async_db),
):
    """Get company details for a user."""
    user_id = request.user_id
    if not user_id:
        raise HTTPException(status_code=400, detail="user_id is required")

    try:
        company_reg_no = current_user.get("company_reg_no")
        if not company_reg_no:
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail="User company association not found",
            )

        profile = await TenantService.get_tenant_profile(db, user_id, company_reg_no)
        if not profile:
            raise HTTPException(
                status_code=404,
                detail="User has no associated company or access denied",
            )

        company_id = profile.get("company_id")
        if not company_id:
            raise HTTPException(status_code=404, detail="User has no associated company")

        stmt = select(Company).where(
            Company.id == company_id, Company.company_reg_no == company_reg_no
        )
        result = await db.execute(stmt)
        company = result.scalar_one_or_none()

        if not company:
            raise HTTPException(status_code=404, detail="Company not found")

        name = profile.get("company_name") or company.name

        if not profile.get("company_name"):
            try:
                await TenantService.update_tenant_profile(
                    db,
                    user_id,
                    {"company_name": name, "updated_at": datetime.utcnow()},
                    company_reg_no,
                )
                logger.info(f"Updated profile for user {user_id} with company name {name}")
            except Exception as err:
                logger.warning(f"Failed to update profile for user {user_id}: {err}")

        return {
            "company": {
                "id": str(company.id),
                "name": name,
                "registered_since": (
                    company.registered_since.isoformat() if company.registered_since else ""
                ),
            }
        }
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Error fetching user company: {e}")
        raise HTTPException(status_code=500, detail="Error fetching user company") from e


# ==================== UPDATE USER DETAILS ====================


class OrganisationDetails(BaseModel):
    firstName: str
    lastName: str
    email: str
    telephone: str
    company: str
    registeredSince: str
    user_id: str | None = None


class UpdateUserDetailsRequest(BaseModel):
    firstName: str
    lastName: str
    email: EmailStr
    telephone: str
    company: str
    user_id: str | None = None
    username: str | None = None
    roles: list[str] | None = None


@app.post("/api/user/update_user_details", response_model=OrganisationDetails)
async def update_user_details(
    request: UpdateUserDetailsRequest,
    current_user: dict = Depends(verify_token_with_tenant),
    db: AsyncSession = Depends(get_async_db),
):
    """Update or add user details (Administrator only)."""
    try:
        company_reg_no = current_user.get("company_reg_no")
        if not company_reg_no:
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail="User company association not found",
            )

        # Admin check using SQLAlchemy
        current_user_id = current_user.get("user_id")
        stmt = (
            select(UserRole.role_id)
            .join(Role)
            .where(
                UserRole.user_id == current_user_id,
                UserRole.company_reg_no == company_reg_no,
                Role.name == "Administrator",
            )
        )
        result = await db.execute(stmt)
        is_admin = result.scalar_one_or_none() is not None

        if not is_admin:
            logger.warning(
                f"User {current_user_id} attempted to access admin endpoint "
                f"without Administrator role in tenant {company_reg_no}."
            )
            raise HTTPException(
                status_code=403,
                detail="User does not have permission to perform this action. Administrator role required.",
            )

        current_date = datetime.utcnow()
        first_name = request.firstName
        last_name = request.lastName
        requested_company_name = request.company
        user_id_from_request = request.user_id
        email = request.email
        telephone = request.telephone
        requested_username = request.username
        requested_roles = request.roles

        logger.info(
            f"Processing user update/creation for tenant {company_reg_no}. "
            f"Company name: '{requested_company_name}'."
        )

        db_user_id = None
        is_existing_profile = False

        if user_id_from_request:
            existing_profile = await TenantService.get_tenant_profile(
                db, user_id_from_request, company_reg_no
            )
            if existing_profile:
                is_existing_profile = True
                db_user_id = existing_profile["id"]

                # Check email uniqueness
                if email != existing_profile["email"]:
                    tenant_profiles = await TenantService.get_tenant_profiles(db, company_reg_no)
                    for profile in tenant_profiles:
                        if profile["email"] == email and profile["id"] != db_user_id:
                            raise HTTPException(
                                status_code=400,
                                detail=f"Email '{email}' is already in use by another user in your organization.",
                            )

                # Check username uniqueness
                if requested_username and requested_username != existing_profile.get("username"):
                    for profile in tenant_profiles:
                        if (
                            profile.get("username") == requested_username
                            and profile["id"] != db_user_id
                        ):
                            raise HTTPException(
                                status_code=400,
                                detail=f"Username '{requested_username}' is already taken in your organization.",
                            )
            else:
                raise HTTPException(
                    status_code=404,
                    detail=f"User with ID '{user_id_from_request}' not found in your organization.",
                )
        else:
            tenant_profiles = await TenantService.get_tenant_profiles(db, company_reg_no)
            for profile in tenant_profiles:
                if profile["email"] == email:
                    is_existing_profile = True
                    db_user_id = profile["id"]

                    if requested_username and requested_username != profile.get("username"):
                        for other_profile in tenant_profiles:
                            if (
                                other_profile.get("username") == requested_username
                                and other_profile["id"] != db_user_id
                            ):
                                raise HTTPException(
                                    status_code=400,
                                    detail=f"Username '{requested_username}' is already taken in your organization.",
                                )
                    break

            if not is_existing_profile:
                if requested_username:
                    for profile in tenant_profiles:
                        if profile.get("username") == requested_username:
                            raise HTTPException(
                                status_code=400,
                                detail=f"Username '{requested_username}' is already taken in your organization.",
                            )
                else:
                    base_username = f"{first_name.lower().replace(' ', '')}_{last_name.lower().replace(' ', '')}{random.randint(100, 999)}"
                    requested_username = base_username
                    while any(
                        profile.get("username") == requested_username for profile in tenant_profiles
                    ):
                        requested_username = f"{first_name.lower().replace(' ', '')}_{last_name.lower().replace(' ', '')}{random.randint(100, 999)}"

        profile_data_to_update = {
            "full_name": f"{first_name} {last_name}",
            "email": email,
            "telephone": telephone,
            "company_name": requested_company_name,
            "company_reg_no": company_reg_no,
            "updated_at": current_date,
        }
        if requested_username:
            profile_data_to_update["username"] = requested_username

        # Validate required fields
        required_fields_check = {
            "email": profile_data_to_update["email"],
            "full_name": profile_data_to_update["full_name"],
            "telephone": profile_data_to_update["telephone"],
            "company_name": profile_data_to_update["company_name"],
        }
        missing_fields = [
            field_name for field_name, value in required_fields_check.items() if not value
        ]
        if missing_fields:
            formatted_fields = [field.replace("_", " ") for field in missing_fields]
            missing_fields_str = ", ".join(formatted_fields)
            raise HTTPException(
                status_code=400,
                detail=f"The following fields are required for profile: {missing_fields_str}",
            )

        if is_existing_profile:
            if not db_user_id:
                raise HTTPException(
                    status_code=500,
                    detail="User ID missing for existing profile update.",
                )
            await TenantService.update_tenant_profile(
                db, db_user_id, profile_data_to_update, company_reg_no
            )
            logger.info(f"Profile updated for user ID: {db_user_id} in tenant {company_reg_no}")
        else:
            password = "".join(random.choices(string.ascii_letters + string.digits, k=12))
            if not profile_data_to_update.get("username"):
                profile_data_to_update["username"] = requested_username

            try:
                # Create user using AuthService
                new_user = await AuthService.create_user(
                    db=db,
                    email=email,
                    password=password,
                    full_name=profile_data_to_update["full_name"],
                )
                db_user_id = str(new_user.id)
                profile_data_to_update["id"] = db_user_id

                # Create profile
                await TenantService.create_tenant_profile(
                    db, profile_data_to_update, company_reg_no
                )
                logger.info(
                    f"Profile created for new user ID: {db_user_id} in tenant {company_reg_no}"
                )

                # Send welcome email
                username_for_email = profile_data_to_update.get("username")
                if not username_for_email:
                    logger.error(f"Username is unexpectedly None for new user {db_user_id}")
                    username_for_email = "User"

                await send_welcome_email(email, password, username_for_email)
            except Exception as e:
                await db.rollback()
                logger.error(f"Error creating user account: {e}")
                raise HTTPException(
                    status_code=500, detail=f"Error creating user account: {str(e)}"
                )

        # Handle roles
        if db_user_id and requested_roles is not None:
            role_ids_to_assign = []
            if requested_roles:
                stmt = select(Role.id, Role.name).where(Role.name.in_(requested_roles))
                result = await db.execute(stmt)
                roles_from_db = result.all()

                role_map = {role.name: str(role.id) for role in roles_from_db}
                for role_name in requested_roles:
                    if role_name in role_map:
                        role_ids_to_assign.append(role_map[role_name])
                    else:
                        logger.warning(f"Role name '{role_name}' not found in database. Skipping.")

            # Clear existing roles
            stmt = select(UserRole).where(
                UserRole.user_id == db_user_id, UserRole.company_reg_no == company_reg_no
            )
            result = await db.execute(stmt)
            existing_roles = result.scalars().all()

            for role in existing_roles:
                await db.delete(role)

            logger.info(
                f"Cleared existing roles for user ID: {db_user_id} in tenant {company_reg_no}"
            )

            # Assign new roles
            if role_ids_to_assign:
                for role_id in role_ids_to_assign:
                    user_role = UserRole(
                        user_id=db_user_id,
                        role_id=role_id,
                        company_reg_no=company_reg_no,
                    )
                    db.add(user_role)

                await db.commit()
                logger.info(
                    f"Assigned new roles to user ID: {db_user_id} in tenant {company_reg_no} - Roles: {requested_roles}"
                )

        response_data = {
            "firstName": first_name,
            "lastName": last_name,
            "email": email,
            "telephone": telephone,
            "company": requested_company_name,
            "registeredSince": current_date.isoformat(),
            "user_id": db_user_id,
        }
        return response_data

    except HTTPException:
        raise
    except Exception as e:
        await db.rollback()
        logger.error(f"Error updating organisation details: {str(e)}")
        raise HTTPException(
            status_code=500, detail=f"Error updating organisation details: {str(e)}"
        ) from e


# ==================== DELETE USER ====================


class DeleteUserResponse(BaseModel):
    message: str


@app.delete(
    "/api/admin/users/{user_id}",
    status_code=200,
    response_model=DeleteUserResponse,
    dependencies=[Depends(require_roles(["Administrator"]))],
)
async def admin_users_delete(user_id: str, db: AsyncSession = Depends(get_async_db)):
    """Delete a user from the system."""
    try:
        # Check if user has sessions
        stmt = select(Session.id).where(Session.user_id == user_id).limit(1)
        result = await db.execute(stmt)
        has_session = result.scalar_one_or_none() is not None

        if not has_session:
            # Hard delete
            stmt = select(User).where(User.id == user_id)
            result = await db.execute(stmt)
            user = result.scalar_one_or_none()

            if user:
                await db.delete(user)
                await db.commit()
                logger.info(f"Deleted user {user_id}")

            stmt = select(Profile).where(Profile.id == user_id)
            result = await db.execute(stmt)
            profile = result.scalar_one_or_none()

            if profile:
                await db.delete(profile)
                await db.commit()
                logger.info(f"Deleted profile {user_id}")

            return {"message": f"User {user_id} permanently deleted."}

        # Soft delete
        stmt = select(Profile).where(Profile.id == user_id)
        result = await db.execute(stmt)
        profile = result.scalar_one_or_none()

        if not profile:
            logger.warning(f"Profile not found for {user_id}")
            return {"message": f"User {user_id} was not found, considered deleted."}

        # Update user status
        stmt = select(User).where(User.id == user_id)
        result = await db.execute(stmt)
        user = result.scalar_one_or_none()

        if user:
            user.email_confirmed_at = None
            user.banned_until = None

        # Update profile status
        profile.status = "inactive"
        profile.updated_at = datetime.utcnow()

        await db.commit()
        logger.info(f"Deactivated user {user_id}")

        return {"message": f"User {user_id} successfully deactivated."}

    except HTTPException:
        raise
    except Exception as err:
        await db.rollback()
        logger.error(f"Unexpected error for {user_id}: {err}")
        raise HTTPException(status_code=500, detail=f"An unexpected error occurred: {err}") from err


# ==================== COMPANY THEME SETTINGS ====================


class GetCompanyThemeSettingsRequest(BaseModel):
    user_id: str


class CompanyThemeSettingsResponse(BaseModel):
    id: str
    name: str
    user_chat_bubble_colour: str | None = None
    bot_chat_bubble_colour: str | None = None
    send_button_and_box: str | None = None
    font: str | None = None
    user_chat_font_colour: str | None = None
    bot_chat_font_colour: str | None = None
    logo: str | None = None
    bot_profile_picture: str | None = None


def ensure_color_has_hash(color_value: str) -> str:
    """Ensure color value has # prefix."""
    if not color_value:
        return color_value
    if color_value.startswith("#"):
        return color_value
    if len(color_value) in [3, 6] and all(c in "0123456789ABCDEFabcdef" for c in color_value):
        return f"#{color_value}"
    return color_value


@app.post("/api/v1/companies/get_theme_settings")
async def get_company_theme_settings(
    request: GetCompanyThemeSettingsRequest, db: AsyncSession = Depends(get_async_db)
):
    """Get company theme settings."""
    try:
        user_id = request.user_id
        logger.info(f"Fetching theme settings for user ID: {user_id}")

        default_settings = {
            "status": "success",
            "theme_settings": {
                "id": "default",
                "name": "Default Company",
                "userChatBubbleColor": "#007bff",
                "botChatBubbleColor": "#e5e5ea",
                "sendButtonAndBox": "#ffffff",
                "font": "Tahoma",
                "userChatFontColor": "#000000",
                "botChatFontColor": "#000000",
                "logo": None,
                "botProfilePicture": None,
            },
        }

        stmt = select(Profile.company_id).where(Profile.id == user_id)
        result = await db.execute(stmt)
        company_id = result.scalar_one_or_none()

        if not company_id:
            logger.warning(f"No company found for user {user_id}")
            return default_settings

        stmt = select(Company).where(Company.id == company_id)
        result = await db.execute(stmt)
        company = result.scalar_one_or_none()

        if not company:
            logger.warning(f"No company found for ID {company_id}")
            return default_settings

        transformed_data = {
            "id": str(company.id),
            "name": company.name,
            "userChatBubbleColor": ensure_color_has_hash(
                company.user_chat_bubble_colour or "#007bff"
            ),
            "botChatBubbleColor": ensure_color_has_hash(
                company.bot_chat_bubble_colour or "#e5e5ea"
            ),
            "sendButtonAndBox": ensure_color_has_hash(company.send_button_and_box or "#ffffff"),
            "font": company.font or "Tahoma",
            "userChatFontColor": ensure_color_has_hash(company.user_chat_font_colour or "#000000"),
            "botChatFontColor": ensure_color_has_hash(company.bot_chat_font_colour or "#000000"),
            "logo": company.logo,
            "botProfilePicture": company.bot_profile_picture,
        }

        return {"status": "success", "theme_settings": transformed_data}

    except Exception as e:
        logger.error(f"Error in get_company_theme_settings: {str(e)}")
        raise HTTPException(status_code=500, detail=str(e))


class CompanyThemeSettingsPayload(BaseModel):
    user_chat_bubble_colour: str | None = None
    bot_chat_bubble_colour: str | None = None
    send_button_and_box: str | None = None
    font: str | None = None
    user_chat_font_colour: str | None = None
    bot_chat_font_colour: str | None = None
    logo: str | None = None
    bot_profile_picture: str | None = None


class UpdateCompanyThemeSettingsRequest(BaseModel):
    user_id: str
    theme_settings: CompanyThemeSettingsPayload


@app.post("/api/v1/companies/update_theme_settings")
async def update_company_theme_settings(
    request_data: UpdateCompanyThemeSettingsRequest, db: AsyncSession = Depends(get_async_db)
):
    """Update company theme settings with Cloudinary support."""
    try:
        user_id = request_data.user_id
        theme_settings = request_data.theme_settings

        logger.info(f"Updating theme settings for user ID: {user_id}")

        if not user_id or not theme_settings:
            raise HTTPException(
                status_code=400,
                detail="Missing required fields: user_id or theme_settings",
            )

        stmt = select(Profile.company_id).where(Profile.id == user_id)
        result = await db.execute(stmt)
        company_id = result.scalar_one_or_none()

        if not company_id:
            raise HTTPException(
                status_code=404, detail="User profile or company association not found"
            )

        stmt = select(Company).where(Company.id == company_id)
        result = await db.execute(stmt)
        company = result.scalar_one_or_none()

        if not company:
            raise HTTPException(status_code=404, detail="Company not found")

        company_name = company.name
        if not company_name:
            raise HTTPException(status_code=500, detail="Company name not found")

        # Update text-based settings
        text_settings_map = {
            "user_chat_bubble_colour": theme_settings.user_chat_bubble_colour,
            "bot_chat_bubble_colour": theme_settings.bot_chat_bubble_colour,
            "send_button_and_box": theme_settings.send_button_and_box,
            "font": theme_settings.font,
            "user_chat_font_colour": theme_settings.user_chat_font_colour,
            "bot_chat_font_colour": theme_settings.bot_chat_font_colour,
        }

        for key, value in text_settings_map.items():
            if key in theme_settings.model_fields_set:
                setattr(company, key, value)

        # Handle Logo - CLOUDINARY
        if "logo" in theme_settings.model_fields_set:
            logo_data = theme_settings.logo
            if logo_data and logo_data.startswith("data:image"):
                try:
                    logo_url = StorageService.upload_logo(logo_data, company_name)
                    company.logo = logo_url
                    logger.info(f"Logo uploaded successfully for company {company_name}")
                except Exception as upload_error:
                    logger.error(f"Error uploading logo: {upload_error}")
                    raise HTTPException(
                        status_code=500,
                        detail=f"Error uploading logo: {str(upload_error)}",
                    )
            elif logo_data is None:
                company.logo = None

        # Handle Bot Profile Picture - CLOUDINARY
        if "bot_profile_picture" in theme_settings.model_fields_set:
            bot_pic_data = theme_settings.bot_profile_picture
            if bot_pic_data and bot_pic_data.startswith("data:image"):
                try:
                    bot_profile_url = StorageService.upload_bot_profile(bot_pic_data, company_name)
                    company.bot_profile_picture = bot_profile_url
                    logger.info(f"Bot profile uploaded successfully for company {company_name}")
                except Exception as upload_error:
                    logger.error(f"Error uploading bot profile: {upload_error}")
                    raise HTTPException(
                        status_code=500,
                        detail=f"Error uploading bot profile: {str(upload_error)}",
                    )
            elif bot_pic_data is None:
                company.bot_profile_picture = None

        await db.commit()
        await db.refresh(company)
        logger.info(f"Theme settings updated successfully for company {company_name}")

        return {
            "status": "success",
            "message": "Company theme settings updated successfully",
        }

    except HTTPException:
        raise
    except Exception as e:
        await db.rollback()
        logger.error(f"Error updating company theme settings: {str(e)}")
        raise HTTPException(status_code=500, detail=str(e)) from e


# ==================== EMAIL TESTING ====================


class EmailTestRequest(BaseModel):
    recipient_email: str
    subject: str | None = "Test Email from Vault"
    content: str | None = "This is a test email from the Vault application."
    username: str | None = None


@app.post("/api/utils/test-email")
async def test_email(request: EmailTestRequest):
    """Test email sending functionality."""
    try:
        email_content = request.content if request.content is not None else ""

        success = await email_service.send_test_email(
            email=request.recipient_email,
            subject=(request.subject if request.subject is not None else "Test Email from Vault"),
            content=email_content,
            username=request.username,
        )

        if success:
            logger.info(f"Test email sent successfully to {request.recipient_email}")
            return {
                "status": "success",
                "message": f"Test email sent successfully to {request.recipient_email}",
                "details": {
                    "recipient": request.recipient_email,
                    "subject": (
                        request.subject if request.subject is not None else "Test Email from Vault"
                    ),
                    "content": (
                        email_content[:50] + "..." if len(email_content) > 50 else email_content
                    ),
                },
            }
        else:
            error_detail = email_service.LAST_EMAIL_ERROR or "unknown error"
            logger.error(f"Failed to send test email to {request.recipient_email}: {error_detail}")
            return {
                "status": "error",
                "message": f"Failed to send test email to {request.recipient_email}",
                "error": error_detail,
            }

    except Exception as e:
        logger.error(f"Error in test-email endpoint: {str(e)}")
        raise HTTPException(status_code=500, detail=f"Error sending test email: {str(e)}") from e


# ==================== PASSWORD MANAGEMENT ====================


class PasswordResetRequestModel(BaseModel):
    email: EmailStr


class PasswordResetResponse(BaseModel):
    status: str
    message: str


@app.post("/api/auth/reset-password-request", response_model=PasswordResetResponse)
async def request_password_reset(
    request: PasswordResetRequestModel, db: AsyncSession = Depends(get_async_db)
):
    """Request password reset."""
    try:
        stmt = select(Profile.id).where(Profile.email == request.email)
        result = await db.execute(stmt)
        profile = result.scalar_one_or_none()

        if not profile:
            return {
                "status": "success",
                "message": "If the email exists, a password reset link has been sent.",
            }

        reset_token = AuthService.create_password_reset_token(request.email)
        await email_service.send_password_reset_email(request.email, reset_token)
        logger.info(f"Sent password reset link to {request.email}")

        return {
            "status": "success",
            "message": "Password reset instructions have been sent to your email",
        }

    except Exception as e:
        logger.error(f"Error in password reset request: {e}")
        raise HTTPException(
            status_code=500, detail="Error processing password reset request"
        ) from e


class ChangePasswordModel(BaseModel):
    user_id: str
    current_password: str
    new_password: str


@app.post("/api/auth/change-password")
async def change_password(request: ChangePasswordModel, db: AsyncSession = Depends(get_async_db)):
    """Change user password."""
    try:
        user, profile = await AuthService.get_user_with_roles(db, request.user_id)

        if not user or not profile:
            raise HTTPException(status_code=404, detail="User not found")

        if not AuthService.verify_password(request.current_password, user.encrypted_password):
            raise HTTPException(status_code=401, detail="Current password is incorrect")

        user.encrypted_password = AuthService.hash_password(request.new_password)

        stmt = select(Session).where(Session.user_id == request.user_id)
        result = await db.execute(stmt)
        session = result.scalar_one_or_none()

        if session:
            session.password_changed = True
            session.updated_at = datetime.utcnow()

        await db.commit()
        logger.info(f"Password changed successfully for {request.user_id}")

        return {"status": "success", "message": "Password changed successfully"}

    except HTTPException:
        raise
    except Exception as e:
        await db.rollback()
        logger.error(f"Error changing password: {e}")
        raise HTTPException(status_code=500, detail="Error changing password") from e


class CheckFirstLoginModel(BaseModel):
    user_id: str


@app.post("/api/auth/check-first-login")
async def check_first_login(
    request: CheckFirstLoginModel, db: AsyncSession = Depends(get_async_db)
):
    """Check if user needs to change password on first login."""
    try:
        stmt = (
            select(Session.password_changed)
            .where(Session.user_id == request.user_id)
            .order_by(Session.created_at.desc())
            .limit(1)
        )
        result = await db.execute(stmt)
        password_changed = result.scalar_one_or_none()

        if password_changed is None or not password_changed:
            if password_changed is None:
                new_session = Session(
                    user_id=request.user_id,
                    status="Started",
                    password_changed=False,
                )
                db.add(new_session)
                await db.commit()

            return {
                "status": "success",
                "first_login": True,
                "require_password_change": True,
            }

        return {
            "status": "success",
            "first_login": False,
            "require_password_change": False,
        }

    except Exception as e:
        logger.error(f"Error checking first login status: {str(e)}")
        raise HTTPException(status_code=500, detail=f"Error checking login status: {str(e)}") from e


# ==================== COMPANY CONTACT DETAILS ====================


class CompanyContactDetails(BaseModel):
    firstName: str
    lastName: str
    email: str
    telephone: str
    company: str
    registeredSince: str


class GetCompanyContactDetailsRequest(BaseModel):
    user_id: str


class UpdateCompanyContactDetailsRequest(BaseModel):
    user_id: str
    firstName: str
    lastName: str
    email: EmailStr
    telephone: str


@app.post("/api/company/contact_details", response_model=CompanyContactDetails)
async def get_company_contact_details(
    request: GetCompanyContactDetailsRequest,
    current_user: dict = Depends(verify_token),
    db: AsyncSession = Depends(get_async_db),
):
    """Get company contact details."""
    try:
        user_id = request.user_id
        if not user_id:
            raise HTTPException(status_code=400, detail="user_id is required")

        stmt = select(Profile.company_id).where(Profile.id == user_id)
        result = await db.execute(stmt)
        company_id = result.scalar_one_or_none()

        if not company_id:
            raise HTTPException(status_code=404, detail="User has no associated company")

        stmt = select(Company).where(Company.id == company_id)
        result = await db.execute(stmt)
        company = result.scalar_one_or_none()

        if not company:
            raise HTTPException(status_code=404, detail="Company not found")

        return CompanyContactDetails(
            firstName=company.contact_first_name or "",
            lastName=company.contact_last_name or "",
            email=company.contact_email or "",
            telephone=company.contact_telephone or "",
            company=company.name or "",
            registeredSince=(
                company.registered_since.isoformat() if company.registered_since else ""
            ),
        )

    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Error fetching company contact details: {e}")
        raise HTTPException(status_code=500, detail="Error fetching company contact details") from e


@app.post("/api/company/update_contact_details", response_model=CompanyContactDetails)
async def update_company_contact_details(
    request: UpdateCompanyContactDetailsRequest,
    current_user: dict = Depends(verify_token),
    db: AsyncSession = Depends(get_async_db),
):
    """Update company contact details (Administrator only)."""
    try:
        # Admin check
        current_user_id = current_user.get("user_id")
        stmt = (
            select(UserRole.role_id)
            .join(Role)
            .where(UserRole.user_id == current_user_id, Role.name == "Administrator")
        )
        result = await db.execute(stmt)
        is_admin = result.scalar_one_or_none() is not None

        if not is_admin:
            logger.warning(
                f"User {current_user_id} attempted to update company contact details "
                f"without Administrator role."
            )
            raise HTTPException(
                status_code=403,
                detail="User does not have permission to perform this action. Administrator role required.",
            )

        user_id = request.user_id
        if not user_id:
            raise HTTPException(status_code=400, detail="user_id is required")

        stmt = select(Profile.company_id).where(Profile.id == user_id)
        result = await db.execute(stmt)
        company_id = result.scalar_one_or_none()

        if not company_id:
            raise HTTPException(status_code=404, detail="User has no associated company")

        stmt = select(Company).where(Company.id == company_id)
        result = await db.execute(stmt)
        company = result.scalar_one_or_none()

        if not company:
            raise HTTPException(status_code=404, detail="Company not found")

        company.contact_first_name = request.firstName
        company.contact_last_name = request.lastName
        company.contact_email = request.email
        company.contact_telephone = request.telephone

        await db.commit()
        await db.refresh(company)

        logger.info(f"Company contact details updated for company ID: {company_id}")

        return CompanyContactDetails(
            firstName=company.contact_first_name or "",
            lastName=company.contact_last_name or "",
            email=company.contact_email or "",
            telephone=company.contact_telephone or "",
            company=company.name or "",
            registeredSince=(
                company.registered_since.isoformat() if company.registered_since else ""
            ),
        )

    except HTTPException:
        raise
    except Exception as e:
        await db.rollback()
        logger.error(f"Error updating company contact details: {e}")
        raise HTTPException(status_code=500, detail="Error updating company contact details") from e


if __name__ == "__main__":
    uvicorn.run(app, host="0.0.0.0", port=7860)
