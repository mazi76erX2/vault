-- Initial schema migration for AI Vault
-- This migration creates all tables, enums, and functions required for the application
-- Includes multi-tenancy support

-- Enable necessary extensions
CREATE EXTENSION IF NOT EXISTS "uuid-ossp";

-- Create custom enums
CREATE TYPE public.securitylevel AS ENUM('Public','Low','High', 'Critical', 'Medium');
CREATE TYPE public.statusenum AS ENUM('Draft','Pending','On Review', 'Rejected', 'Validated - Stored', 'Validated - Awaiting Approval');
CREATE TYPE public.sessionstatusenum AS ENUM('Not Started','Started','Completed', 'In Progress');
CREATE TYPE public.document_status AS ENUM('pending','in_progress','completed');
CREATE TYPE public.user_access_levels AS ENUM('admin','manager','employee', 'guest');
CREATE TYPE public.department AS ENUM('AI CC','Planning','Analytics', 'HR', 'Data & Cloud', 'Sales', 'Marketing');
CREATE TYPE public.ldap_connector_status AS ENUM ('inactive', 'active', 'syncing', 'failed', 'complete');

-- Create companies table (core table for multi-tenancy)
CREATE TABLE public.companies (
  id bigint GENERATED BY DEFAULT AS IDENTITY NOT NULL,
  created_at timestamp with time zone NOT NULL DEFAULT now(),
  name text NOT NULL,
  registered_since date NOT NULL,
  user_chat_bubble_colour text NULL DEFAULT '#007bff',
  bot_chat_bubble_colour text NULL DEFAULT '#e5e5ea',
  send_button_and_box text NULL DEFAULT '#ffffff',
  font text NULL DEFAULT 'Tahoma',
  logo text NULL,
  bot_profile_picture text NULL,
  user_chat_font_colour text NULL DEFAULT '#000000',
  bot_chat_font_colour text NULL DEFAULT '#000000',
  contact_user_id uuid NULL,
  contact_first_name text NULL,
  contact_last_name text NULL,
  contact_email text NULL,
  contact_telephone text NULL,
  company_reg_no text NOT NULL UNIQUE, -- Multi-tenancy key
  CONSTRAINT company_pkey PRIMARY KEY (id)
);

-- Create user_types table
CREATE TABLE public.user_types (
  id bigint GENERATED BY DEFAULT AS IDENTITY NOT NULL,
  name text NOT NULL,
  description text NULL,
  created_at timestamp with time zone NOT NULL DEFAULT now(),
  CONSTRAINT user_types_pkey PRIMARY KEY (id),
  CONSTRAINT user_types_name_key UNIQUE (name)
);

-- Create profiles table (users)
CREATE TABLE public.profiles (
  id uuid NOT NULL,
  updated_at timestamp with time zone NULL,
  username text NULL,
  full_name text NULL,
  website text NULL,
  department text NULL,
  field_of_expertise text NULL,
  years_of_experience text NULL,
  "CV_text" text NULL,
  "isValidator" boolean NOT NULL DEFAULT false,
  user_access public.user_access_levels NULL DEFAULT 'employee'::user_access_levels,
  telephone text NULL,
  email text NULL,
  company_id bigint NULL,
  company_name text NULL,
  user_type bigint NULL,
  created_at timestamp with time zone NOT NULL DEFAULT now(),
  company_reg_no text NULL, -- Multi-tenancy key
  status text NULL DEFAULT 'active',
  CONSTRAINT profiles_pkey PRIMARY KEY (id),
  CONSTRAINT profiles_username_key UNIQUE (username),
  CONSTRAINT profiles_id_fkey FOREIGN KEY (id) REFERENCES auth.users (id) ON DELETE CASCADE,
  CONSTRAINT profiles_company_id_fkey FOREIGN KEY (company_id) REFERENCES companies (id),
  CONSTRAINT profiles_user_type_fkey FOREIGN KEY (user_type) REFERENCES user_types (id),
  CONSTRAINT username_length CHECK ((char_length(username) >= 3))
);

-- Create roles table
CREATE TABLE public.roles (
  id uuid NOT NULL DEFAULT uuid_generate_v4(),
  name text NOT NULL,
  description text NULL,
  created_at timestamp with time zone NULL DEFAULT now(),
  CONSTRAINT roles_pkey PRIMARY KEY (id),
  CONSTRAINT roles_name_key UNIQUE (name)
);

-- Create user_roles table (with multi-tenancy support)
CREATE TABLE public.user_roles (
  user_id uuid NOT NULL,
  role_id uuid NOT NULL,
  assigned_at timestamp with time zone NULL DEFAULT now(),
  company_reg_no text NOT NULL, -- Multi-tenancy key
  CONSTRAINT user_roles_pkey PRIMARY KEY (user_id, role_id, company_reg_no),
  CONSTRAINT user_roles_user_id_fkey FOREIGN KEY (user_id) REFERENCES profiles (id) ON DELETE CASCADE,
  CONSTRAINT user_roles_role_id_fkey FOREIGN KEY (role_id) REFERENCES roles (id) ON DELETE RESTRICT
);

-- Create sessions table
CREATE TABLE public.sessions (
  id uuid NOT NULL DEFAULT uuid_generate_v4(),
  user_id uuid NOT NULL,
  status public.sessionstatusenum NULL DEFAULT 'Not Started'::sessionstatusenum,
  created_at timestamp with time zone NOT NULL DEFAULT now(),
  updated_at timestamp with time zone NULL,
  password_changed boolean NULL DEFAULT false,
  CONSTRAINT sessions_pkey PRIMARY KEY (id),
  CONSTRAINT sessions_user_id_fkey FOREIGN KEY (user_id) REFERENCES profiles (id) ON DELETE CASCADE
);

-- Create documents table
CREATE TABLE public.documents (
  doc_id uuid NOT NULL DEFAULT uuid_generate_v4(),
  title text NULL,
  content text NULL,
  summary text NULL,
  severity_levels public.securitylevel NULL,
  status public.statusenum NULL,
  reviewer uuid NULL,
  link text NULL,
  created_at timestamp with time zone NOT NULL DEFAULT now(),
  updated_at timestamp with time zone NULL,
  CONSTRAINT documents_pkey PRIMARY KEY (doc_id),
  CONSTRAINT documents_reviewer_fkey FOREIGN KEY (reviewer) REFERENCES profiles (id)
);

-- Create document_assignments table
CREATE TABLE public.document_assignments (
  id uuid NOT NULL DEFAULT uuid_generate_v4(),
  document_id uuid NOT NULL,
  assigned_to uuid NOT NULL,
  assigned_by uuid NOT NULL,
  assigned_at timestamp with time zone NOT NULL DEFAULT now(),
  status public.document_status NULL DEFAULT 'pending'::document_status,
  CONSTRAINT document_assignments_pkey PRIMARY KEY (id),
  CONSTRAINT document_assignments_document_id_fkey FOREIGN KEY (document_id) REFERENCES documents (doc_id) ON DELETE CASCADE,
  CONSTRAINT document_assignments_assigned_to_fkey FOREIGN KEY (assigned_to) REFERENCES profiles (id),
  CONSTRAINT document_assignments_assigned_by_fkey FOREIGN KEY (assigned_by) REFERENCES profiles (id)
);

-- Create questions table
CREATE TABLE public.questions (
  id uuid NOT NULL DEFAULT uuid_generate_v4(),
  question_text text NOT NULL,
  user_id uuid NOT NULL,
  created_at timestamp with time zone NOT NULL DEFAULT now(),
  session_id uuid NULL,
  CONSTRAINT questions_pkey PRIMARY KEY (id),
  CONSTRAINT questions_user_id_fkey FOREIGN KEY (user_id) REFERENCES profiles (id) ON DELETE CASCADE,
  CONSTRAINT questions_session_id_fkey FOREIGN KEY (session_id) REFERENCES sessions (id)
);

-- Create chat_messages_helper table
CREATE TABLE public.chat_messages_helper (
  id uuid NOT NULL DEFAULT uuid_generate_v4(),
  user_id uuid NOT NULL,
  message text NOT NULL,
  timestamp timestamp with time zone NOT NULL DEFAULT now(),
  CONSTRAINT chat_messages_helper_pkey PRIMARY KEY (id),
  CONSTRAINT chat_messages_helper_user_id_fkey FOREIGN KEY (user_id) REFERENCES profiles (id) ON DELETE CASCADE
);

-- Create chat_messages_collector table
CREATE TABLE public.chat_messages_collector (
  id uuid NOT NULL DEFAULT uuid_generate_v4(),
  user_id uuid NOT NULL,
  message text NOT NULL,
  timestamp timestamp with time zone NOT NULL DEFAULT now(),
  CONSTRAINT chat_messages_collector_pkey PRIMARY KEY (id),
  CONSTRAINT chat_messages_collector_user_id_fkey FOREIGN KEY (user_id) REFERENCES profiles (id) ON DELETE CASCADE
);

-- Create ldap_connectors table
CREATE TABLE public.ldap_connectors (
  id uuid NOT NULL DEFAULT uuid_generate_v4(),
  name text NOT NULL,
  server_url text NOT NULL,
  bind_dn text NOT NULL,
  bind_password text NOT NULL,
  search_base text NOT NULL,
  search_filter text NULL DEFAULT '(objectClass=person)',
  user_attributes jsonb NULL DEFAULT '{"username": "sAMAccountName", "email": "mail", "full_name": "displayName", "department": "department"}',
  ssl_enabled boolean NOT NULL DEFAULT false,
  port integer NOT NULL DEFAULT 389,
  timeout integer NOT NULL DEFAULT 30,
  page_size integer NOT NULL DEFAULT 1000,
  status public.ldap_connector_status NOT NULL DEFAULT 'inactive',
  last_sync timestamp with time zone NULL,
  sync_count integer NOT NULL DEFAULT 0,
  error_message text NULL,
  created_at timestamp with time zone NOT NULL DEFAULT now(),
  updated_at timestamp with time zone NOT NULL DEFAULT now(),
  created_by uuid NOT NULL,
  company_id bigint NOT NULL,
  CONSTRAINT ldap_connectors_pkey PRIMARY KEY (id),
  CONSTRAINT ldap_connectors_name_key UNIQUE (name),
  CONSTRAINT ldap_connectors_created_by_fkey FOREIGN KEY (created_by) REFERENCES profiles (id),
  CONSTRAINT ldap_connectors_company_id_fkey FOREIGN KEY (company_id) REFERENCES companies (id) ON DELETE CASCADE
);

-- Add foreign key constraint to companies table (after profiles table is created)
ALTER TABLE public.companies 
ADD CONSTRAINT fk_contact_user 
FOREIGN KEY (contact_user_id) REFERENCES public.profiles (id) ON UPDATE CASCADE ON DELETE SET NULL;

-- Create indexes for performance
CREATE INDEX IF NOT EXISTS idx_companies_contact_email ON public.companies USING btree (contact_email);
CREATE INDEX IF NOT EXISTS idx_companies_company_reg_no ON public.companies USING btree (company_reg_no);
CREATE INDEX IF NOT EXISTS idx_profiles_company_id ON public.profiles USING btree (company_id);
CREATE INDEX IF NOT EXISTS idx_profiles_company_reg_no ON public.profiles USING btree (company_reg_no);
CREATE INDEX IF NOT EXISTS idx_profiles_email ON public.profiles USING btree (email);
CREATE INDEX IF NOT EXISTS idx_user_roles_user_id ON public.user_roles USING btree (user_id);
CREATE INDEX IF NOT EXISTS idx_user_roles_role_id ON public.user_roles USING btree (role_id);
CREATE INDEX IF NOT EXISTS idx_user_roles_company_reg_no ON public.user_roles USING btree (company_reg_no);
CREATE INDEX IF NOT EXISTS idx_sessions_user_id ON public.sessions USING btree (user_id);
CREATE INDEX IF NOT EXISTS idx_documents_reviewer ON public.documents USING btree (reviewer);
CREATE INDEX IF NOT EXISTS idx_ldap_connectors_company_id ON public.ldap_connectors USING btree (company_id);

-- Insert default roles
INSERT INTO public.roles (id, name, description)
VALUES 
    ('4abdeb04-f908-472a-92d0-8d8b1cb6208e', 'Expert', 'Access to the expert option on the dashboard. Listed in Validator''s options when delegating.'),
    ('640955e7-f8ff-4133-bbd5-41b5eab8cb5a', 'Helper', 'End user function of Vault - Allows access to the Helper chat function from the dashboard'),
    ('6674adfb-c0d2-4e02-9b71-f569653d9782', 'Collector', 'Access to the collector option on the dashboard'),
    ('b86db406-e7b5-4cc0-ad2c-39cf0557f367', 'Administrator', 'Full access to the HVMC - User management, Themes, Applications and data sources'),
    ('e49d4a8e-d1ad-4906-82ac-41b875ad0223', 'Validator', 'Access to the validator option on the dashboard')
ON CONFLICT (id) DO UPDATE 
SET 
    name = EXCLUDED.name,
    description = EXCLUDED.description;

-- Insert default user types
INSERT INTO public.user_types (name, description)
VALUES 
    ('Standard User', 'Regular user with basic access'),
    ('Power User', 'User with enhanced capabilities'),
    ('System User', 'System-level user for automated processes')
ON CONFLICT (name) DO NOTHING;

-- Create database functions for multi-tenancy
CREATE OR REPLACE FUNCTION get_company_reg_no_from_user_id(user_id uuid)
RETURNS text
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
    reg_no text;
BEGIN
    SELECT company_reg_no INTO reg_no
    FROM profiles
    WHERE id = user_id;
    
    RETURN reg_no;
END;
$$;

CREATE OR REPLACE FUNCTION user_belongs_to_company(user_id uuid, reg_no text)
RETURNS boolean
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
    user_reg_no text;
BEGIN
    SELECT company_reg_no INTO user_reg_no
    FROM profiles
    WHERE id = user_id;
    
    RETURN user_reg_no = reg_no;
END;
$$;

-- Create function to get enum values (used by the application)
CREATE OR REPLACE FUNCTION get_enum_values(enum_name text)
RETURNS TABLE(enum_value text)
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
BEGIN
    RETURN QUERY
    SELECT unnest(enum_range(NULL::department))::text
    WHERE enum_name = 'department'
    UNION ALL
    SELECT unnest(enum_range(NULL::user_access_levels))::text
    WHERE enum_name = 'user_access_levels'
    UNION ALL
    SELECT unnest(enum_range(NULL::securitylevel))::text
    WHERE enum_name = 'securitylevel'
    UNION ALL
    SELECT unnest(enum_range(NULL::statusenum))::text
    WHERE enum_name = 'statusenum'
    UNION ALL
    SELECT unnest(enum_range(NULL::sessionstatusenum))::text
    WHERE enum_name = 'sessionstatusenum'
    UNION ALL
    SELECT unnest(enum_range(NULL::document_status))::text
    WHERE enum_name = 'document_status'
    UNION ALL
    SELECT unnest(enum_range(NULL::ldap_connector_status))::text
    WHERE enum_name = 'ldap_connector_status';
END;
$$;

-- Enable Row Level Security (RLS) for multi-tenancy
ALTER TABLE public.profiles ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.user_roles ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.companies ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.ldap_connectors ENABLE ROW LEVEL SECURITY;

-- Create RLS policies for tenant isolation
-- Profiles policy: users can only see profiles from their company
CREATE POLICY "Users can only see profiles from their company" ON public.profiles
    FOR ALL USING (
        company_reg_no = (
            SELECT company_reg_no 
            FROM profiles 
            WHERE id = auth.uid()
        )
    );

-- User roles policy: users can only see roles from their company
CREATE POLICY "Users can only see roles from their company" ON public.user_roles
    FOR ALL USING (
        company_reg_no = (
            SELECT company_reg_no 
            FROM profiles 
            WHERE id = auth.uid()
        )
    );

-- Companies policy: users can only see their own company
CREATE POLICY "Users can only see their own company" ON public.companies
    FOR ALL USING (
        company_reg_no = (
            SELECT company_reg_no 
            FROM profiles 
            WHERE id = auth.uid()
        )
    );

-- LDAP connectors policy: users can only see connectors from their company
CREATE POLICY "Users can only see LDAP connectors from their company" ON public.ldap_connectors
    FOR ALL USING (
        company_id = (
            SELECT company_id 
            FROM profiles 
            WHERE id = auth.uid()
        )
    );

-- Grant necessary permissions
GRANT USAGE ON SCHEMA public TO anon, authenticated;
GRANT ALL ON ALL TABLES IN SCHEMA public TO anon, authenticated;
GRANT ALL ON ALL SEQUENCES IN SCHEMA public TO anon, authenticated;
GRANT EXECUTE ON ALL FUNCTIONS IN SCHEMA public TO anon, authenticated;

-- Create trigger to automatically set company_reg_no on profile creation
CREATE OR REPLACE FUNCTION set_profile_company_reg_no()
RETURNS TRIGGER
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
BEGIN
    -- If company_id is set but company_reg_no is not, get it from companies table
    IF NEW.company_id IS NOT NULL AND NEW.company_reg_no IS NULL THEN
        SELECT company_reg_no INTO NEW.company_reg_no
        FROM companies
        WHERE id = NEW.company_id;
    END IF;
    
    RETURN NEW;
END;
$$;

CREATE TRIGGER trigger_set_profile_company_reg_no
    BEFORE INSERT OR UPDATE ON public.profiles
    FOR EACH ROW
    EXECUTE FUNCTION set_profile_company_reg_no();

-- Comments for documentation
COMMENT ON TABLE public.companies IS 'Companies table - core table for multi-tenancy. Each company has a unique company_reg_no.';
COMMENT ON TABLE public.profiles IS 'User profiles table with multi-tenancy support via company_reg_no.';
COMMENT ON TABLE public.user_roles IS 'User roles assignments with multi-tenancy support via company_reg_no.';
COMMENT ON FUNCTION get_company_reg_no_from_user_id(uuid) IS 'Returns the company registration number for a given user ID.';
COMMENT ON FUNCTION user_belongs_to_company(uuid, text) IS 'Checks if a user belongs to a specific company.';
